"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/swr";
exports.ids = ["vendor-chunks/swr"];
exports.modules = {

/***/ "(ssr)/./node_modules/swr/dist/_internal/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/swr/dist/_internal/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INFINITE_PREFIX: () => (/* binding */ INFINITE_PREFIX),\n/* harmony export */   IS_REACT_LEGACY: () => (/* binding */ IS_REACT_LEGACY),\n/* harmony export */   IS_SERVER: () => (/* binding */ IS_SERVER),\n/* harmony export */   OBJECT: () => (/* binding */ OBJECT),\n/* harmony export */   SWRConfig: () => (/* binding */ SWRConfig),\n/* harmony export */   SWRGlobalState: () => (/* binding */ SWRGlobalState),\n/* harmony export */   UNDEFINED: () => (/* binding */ UNDEFINED),\n/* harmony export */   cache: () => (/* binding */ cache),\n/* harmony export */   compare: () => (/* binding */ compare),\n/* harmony export */   createCacheHelper: () => (/* binding */ createCacheHelper),\n/* harmony export */   defaultConfig: () => (/* binding */ defaultConfig),\n/* harmony export */   defaultConfigOptions: () => (/* binding */ defaultConfigOptions),\n/* harmony export */   getTimestamp: () => (/* binding */ getTimestamp),\n/* harmony export */   hasRequestAnimationFrame: () => (/* binding */ hasRequestAnimationFrame),\n/* harmony export */   initCache: () => (/* binding */ initCache),\n/* harmony export */   internalMutate: () => (/* binding */ internalMutate),\n/* harmony export */   isDocumentDefined: () => (/* binding */ isDocumentDefined),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isPromiseLike: () => (/* binding */ isPromiseLike),\n/* harmony export */   isUndefined: () => (/* binding */ isUndefined),\n/* harmony export */   isWindowDefined: () => (/* binding */ isWindowDefined),\n/* harmony export */   mergeConfigs: () => (/* binding */ mergeConfigs),\n/* harmony export */   mergeObjects: () => (/* binding */ mergeObjects),\n/* harmony export */   mutate: () => (/* binding */ mutate),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   preload: () => (/* binding */ preload),\n/* harmony export */   preset: () => (/* binding */ preset),\n/* harmony export */   rAF: () => (/* binding */ rAF),\n/* harmony export */   revalidateEvents: () => (/* binding */ events),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   slowConnection: () => (/* binding */ slowConnection),\n/* harmony export */   stableHash: () => (/* binding */ stableHash),\n/* harmony export */   subscribeCallback: () => (/* binding */ subscribeCallback),\n/* harmony export */   useIsomorphicLayoutEffect: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   useSWRConfig: () => (/* binding */ useSWRConfig),\n/* harmony export */   withArgs: () => (/* binding */ withArgs),\n/* harmony export */   withMiddleware: () => (/* binding */ withMiddleware)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n// Shared state between server components and client components\nconst noop = () => {};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/noop();\nconst OBJECT = Object;\nconst isUndefined = v => v === UNDEFINED;\nconst isFunction = v => typeof v == 'function';\nconst mergeObjects = (a, b) => ({\n  ...a,\n  ...b\n});\nconst isPromiseLike = x => isFunction(x.then);\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = arg => {\n  const type = typeof arg;\n  const constructor = arg && arg.constructor;\n  const isDate = constructor == Date;\n  let result;\n  let index;\n  if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n    // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n    // If it's already hashed, directly return the result.\n    result = table.get(arg);\n    if (result) return result;\n    // Store the hash first for circular reference detection before entering the\n    // recursive `stableHash` calls.\n    // For other objects like set and map, we use this id directly as the hash.\n    result = ++counter + '~';\n    table.set(arg, result);\n    if (constructor == Array) {\n      // Array.\n      result = '@';\n      for (index = 0; index < arg.length; index++) {\n        result += stableHash(arg[index]) + ',';\n      }\n      table.set(arg, result);\n    }\n    if (constructor == OBJECT) {\n      // Object, sort keys.\n      result = '#';\n      const keys = OBJECT.keys(arg).sort();\n      while (!isUndefined(index = keys.pop())) {\n        if (!isUndefined(arg[index])) {\n          result += index + ':' + stableHash(arg[index]) + ',';\n        }\n      }\n      table.set(arg, result);\n    }\n  } else {\n    result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n  }\n  return result;\n};\n\n// Global state used to deduplicate requests and store listeners\nconst SWRGlobalState = new WeakMap();\nconst EMPTY_CACHE = {};\nconst INITIAL_CACHE = {};\nconst STR_UNDEFINED = 'undefined';\n// NOTE: Use the function to guarantee it's re-evaluated between jsdom and node runtime for tests.\nconst isWindowDefined = false;\nconst isDocumentDefined = typeof document != STR_UNDEFINED;\nconst hasRequestAnimationFrame = () => isWindowDefined && typeof window['requestAnimationFrame'] != STR_UNDEFINED;\nconst createCacheHelper = (cache, key) => {\n  const state = SWRGlobalState.get(cache);\n  return [\n  // Getter\n  () => !isUndefined(key) && cache.get(key) || EMPTY_CACHE,\n  // Setter\n  info => {\n    if (!isUndefined(key)) {\n      const prev = cache.get(key);\n      // Before writing to the store, we keep the value in the initial cache\n      // if it's not there yet.\n      if (!(key in INITIAL_CACHE)) {\n        INITIAL_CACHE[key] = prev;\n      }\n      state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);\n    }\n  },\n  // Subscriber\n  state[6],\n  // Get server cache snapshot\n  () => {\n    if (!isUndefined(key)) {\n      // If the cache was updated on the client, we return the stored initial value.\n      if (key in INITIAL_CACHE) return INITIAL_CACHE[key];\n    }\n    // If we haven't done any client-side updates, we return the current value.\n    return !isUndefined(key) && cache.get(key) || EMPTY_CACHE;\n  }];\n} // export { UNDEFINED, OBJECT, isUndefined, isFunction, mergeObjects, isPromiseLike }\n;\n\n/**\n * Due to the bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a workaround, we always assume it's online on the first load, and change\n * the status upon `online` or `offline` events.\n */\nlet online = true;\nconst isOnline = () => online;\n// For node and React Native, `add/removeEventListener` doesn't exist on window.\nconst [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [window.addEventListener.bind(window), window.removeEventListener.bind(window)] : [noop, noop];\nconst isVisible = () => {\n  const visibilityState = isDocumentDefined && document.visibilityState;\n  return isUndefined(visibilityState) || visibilityState !== 'hidden';\n};\nconst initFocus = callback => {\n  // focus revalidate\n  if (isDocumentDefined) {\n    document.addEventListener('visibilitychange', callback);\n  }\n  onWindowEvent('focus', callback);\n  return () => {\n    if (isDocumentDefined) {\n      document.removeEventListener('visibilitychange', callback);\n    }\n    offWindowEvent('focus', callback);\n  };\n};\nconst initReconnect = callback => {\n  // revalidate on reconnected\n  const onOnline = () => {\n    online = true;\n    callback();\n  };\n  // nothing to revalidate, just update the status\n  const onOffline = () => {\n    online = false;\n  };\n  onWindowEvent('online', onOnline);\n  onWindowEvent('offline', onOffline);\n  return () => {\n    offWindowEvent('online', onOnline);\n    offWindowEvent('offline', onOffline);\n  };\n};\nconst preset = {\n  isOnline,\n  isVisible\n};\nconst defaultConfigOptions = {\n  initFocus,\n  initReconnect\n};\nconst IS_REACT_LEGACY = !react__WEBPACK_IMPORTED_MODULE_0__.useId;\nconst IS_SERVER = !isWindowDefined || 'Deno' in window;\n// Polyfill requestAnimationFrame\nconst rAF = f => hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1);\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nconst useIsomorphicLayoutEffect = IS_SERVER ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n// This assignment is to extend the Navigator type to use effectiveType.\nconst navigatorConnection = typeof navigator !== 'undefined' && navigator.connection;\n// Adjust the config based on slow connection status (<= 70Kbps).\nconst slowConnection = !IS_SERVER && navigatorConnection && (['slow-2g', '2g'].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\nconst serialize = key => {\n  if (isFunction(key)) {\n    try {\n      key = key();\n    } catch (err) {\n      // dependencies not ready\n      key = '';\n    }\n  }\n  // Use the original key as the argument of fetcher. This can be a string or an\n  // array of values.\n  const args = key;\n  // If key is not falsy, or not an empty array, hash it.\n  key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n  return [key, args];\n};\n\n// Global timestamp.\nlet __timestamp = 0;\nconst getTimestamp = () => ++__timestamp;\nconst FOCUS_EVENT = 0;\nconst RECONNECT_EVENT = 1;\nconst MUTATE_EVENT = 2;\nconst ERROR_REVALIDATE_EVENT = 3;\nvar events = {\n  __proto__: null,\n  ERROR_REVALIDATE_EVENT: ERROR_REVALIDATE_EVENT,\n  FOCUS_EVENT: FOCUS_EVENT,\n  MUTATE_EVENT: MUTATE_EVENT,\n  RECONNECT_EVENT: RECONNECT_EVENT\n};\nasync function internalMutate(...args) {\n  const [cache, _key, _data, _opts] = args;\n  // When passing as a boolean, it's explicitly used to disable/enable\n  // revalidation.\n  const options = mergeObjects({\n    populateCache: true,\n    throwOnError: true\n  }, typeof _opts === 'boolean' ? {\n    revalidate: _opts\n  } : _opts || {});\n  let populateCache = options.populateCache;\n  const rollbackOnErrorOption = options.rollbackOnError;\n  let optimisticData = options.optimisticData;\n  const rollbackOnError = error => {\n    return typeof rollbackOnErrorOption === 'function' ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;\n  };\n  const throwOnError = options.throwOnError;\n  // If the second argument is a key filter, return the mutation results for all\n  // filtered keys.\n  if (isFunction(_key)) {\n    const keyFilter = _key;\n    const matchedKeys = [];\n    const it = cache.keys();\n    for (const key of it) {\n      if (\n      // Skip the special useSWRInfinite and useSWRSubscription keys.\n      !/^\\$(inf|sub)\\$/.test(key) && keyFilter(cache.get(key)._k)) {\n        matchedKeys.push(key);\n      }\n    }\n    return Promise.all(matchedKeys.map(mutateByKey));\n  }\n  return mutateByKey(_key);\n  async function mutateByKey(_k) {\n    // Serialize key\n    const [key] = serialize(_k);\n    if (!key) return;\n    const [get, set] = createCacheHelper(cache, key);\n    const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache);\n    const startRevalidate = () => {\n      const revalidators = EVENT_REVALIDATORS[key];\n      const revalidate = isFunction(options.revalidate) ? options.revalidate(get().data, _k) : options.revalidate !== false;\n      if (revalidate) {\n        // Invalidate the key by deleting the concurrent request markers so new\n        // requests will not be deduped.\n        delete FETCH[key];\n        delete PRELOAD[key];\n        if (revalidators && revalidators[0]) {\n          return revalidators[0](MUTATE_EVENT).then(() => get().data);\n        }\n      }\n      return get().data;\n    };\n    // If there is no new data provided, revalidate the key with current state.\n    if (args.length < 3) {\n      // Revalidate and broadcast state.\n      return startRevalidate();\n    }\n    let data = _data;\n    let error;\n    // Update global timestamps.\n    const beforeMutationTs = getTimestamp();\n    MUTATION[key] = [beforeMutationTs, 0];\n    const hasOptimisticData = !isUndefined(optimisticData);\n    const state = get();\n    // `displayedData` is the current value on screen. It could be the optimistic value\n    // that is going to be overridden by a `committedData`, or get reverted back.\n    // `committedData` is the validated value that comes from a fetch or mutation.\n    const displayedData = state.data;\n    const currentData = state._c;\n    const committedData = isUndefined(currentData) ? displayedData : currentData;\n    // Do optimistic data update.\n    if (hasOptimisticData) {\n      optimisticData = isFunction(optimisticData) ? optimisticData(committedData, displayedData) : optimisticData;\n      // When we set optimistic data, backup the current committedData data in `_c`.\n      set({\n        data: optimisticData,\n        _c: committedData\n      });\n    }\n    if (isFunction(data)) {\n      // `data` is a function, call it passing current cache value.\n      try {\n        data = data(committedData);\n      } catch (err) {\n        // If it throws an error synchronously, we shouldn't update the cache.\n        error = err;\n      }\n    }\n    // `data` is a promise/thenable, resolve the final data first.\n    if (data && isPromiseLike(data)) {\n      // This means that the mutation is async, we need to check timestamps to\n      // avoid race conditions.\n      data = await data.catch(err => {\n        error = err;\n      });\n      // Check if other mutations have occurred since we've started this mutation.\n      // If there's a race we don't update cache or broadcast the change,\n      // just return the data.\n      if (beforeMutationTs !== MUTATION[key][0]) {\n        if (error) throw error;\n        return data;\n      } else if (error && hasOptimisticData && rollbackOnError(error)) {\n        // Rollback. Always populate the cache in this case but without\n        // transforming the data.\n        populateCache = true;\n        // Reset data to be the latest committed data, and clear the `_c` value.\n        set({\n          data: committedData,\n          _c: UNDEFINED\n        });\n      }\n    }\n    // If we should write back the cache after request.\n    if (populateCache) {\n      if (!error) {\n        // Transform the result into data.\n        if (isFunction(populateCache)) {\n          const populateCachedData = populateCache(data, committedData);\n          set({\n            data: populateCachedData,\n            error: UNDEFINED,\n            _c: UNDEFINED\n          });\n        } else {\n          // Only update cached data and reset the error if there's no error. Data can be `undefined` here.\n          set({\n            data,\n            error: UNDEFINED,\n            _c: UNDEFINED\n          });\n        }\n      }\n    }\n    // Reset the timestamp to mark the mutation has ended.\n    MUTATION[key][1] = getTimestamp();\n    // Update existing SWR Hooks' internal states:\n    Promise.resolve(startRevalidate()).then(() => {\n      // The mutation and revalidation are ended, we can clear it since the data is\n      // not an optimistic value anymore.\n      set({\n        _c: UNDEFINED\n      });\n    });\n    // Throw error or return data\n    if (error) {\n      if (throwOnError) throw error;\n      return;\n    }\n    return data;\n  }\n}\nconst revalidateAllKeys = (revalidators, type) => {\n  for (const key in revalidators) {\n    if (revalidators[key][0]) revalidators[key][0](type);\n  }\n};\nconst initCache = (provider, options) => {\n  // The global state for a specific provider will be used to deduplicate\n  // requests and store listeners. As well as a mutate function that is bound to\n  // the cache.\n  // The provider's global state might be already initialized. Let's try to get the\n  // global state associated with the provider first.\n  if (!SWRGlobalState.has(provider)) {\n    const opts = mergeObjects(defaultConfigOptions, options);\n    // If there's no global state bound to the provider, create a new one with the\n    // new mutate function.\n    const EVENT_REVALIDATORS = {};\n    const mutate = internalMutate.bind(UNDEFINED, provider);\n    let unmount = noop;\n    const subscriptions = {};\n    const subscribe = (key, callback) => {\n      const subs = subscriptions[key] || [];\n      subscriptions[key] = subs;\n      subs.push(callback);\n      return () => subs.splice(subs.indexOf(callback), 1);\n    };\n    const setter = (key, value, prev) => {\n      provider.set(key, value);\n      const subs = subscriptions[key];\n      if (subs) {\n        for (const fn of subs) {\n          fn(value, prev);\n        }\n      }\n    };\n    const initProvider = () => {\n      if (!SWRGlobalState.has(provider)) {\n        // Update the state if it's new, or if the provider has been extended.\n        SWRGlobalState.set(provider, [EVENT_REVALIDATORS, {}, {}, {}, mutate, setter, subscribe]);\n        if (!IS_SERVER) {\n          // When listening to the native events for auto revalidations,\n          // we intentionally put a delay (setTimeout) here to make sure they are\n          // fired after immediate JavaScript executions, which can be\n          // React's state updates.\n          // This avoids some unnecessary revalidations such as\n          // https://github.com/vercel/swr/issues/1680.\n          const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n          const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n          unmount = () => {\n            releaseFocus && releaseFocus();\n            releaseReconnect && releaseReconnect();\n            // When un-mounting, we need to remove the cache provider from the state\n            // storage too because it's a side-effect. Otherwise, when re-mounting we\n            // will not re-register those event listeners.\n            SWRGlobalState.delete(provider);\n          };\n        }\n      }\n    };\n    initProvider();\n    // This is a new provider, we need to initialize it and setup DOM events\n    // listeners for `focus` and `reconnect` actions.\n    // We might want to inject an extra layer on top of `provider` in the future,\n    // such as key serialization, auto GC, etc.\n    // For now, it's just a `Map` interface without any modifications.\n    return [provider, mutate, initProvider, unmount];\n  }\n  return [provider, SWRGlobalState.get(provider)[4]];\n};\n\n// error retry\nconst onErrorRetry = (_, __, config, revalidate, opts) => {\n  const maxRetryCount = config.errorRetryCount;\n  const currentRetryCount = opts.retryCount;\n  // Exponential backoff\n  const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n  if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n    return;\n  }\n  setTimeout(revalidate, timeout, opts);\n};\nconst compare = (currentData, newData) => stableHash(currentData) == stableHash(newData);\n// Default cache provider\nconst [cache, mutate] = initCache(new Map());\n// Default config\nconst defaultConfig = mergeObjects({\n  // events\n  onLoadingSlow: noop,\n  onSuccess: noop,\n  onError: noop,\n  onErrorRetry,\n  onDiscarded: noop,\n  // switches\n  revalidateOnFocus: true,\n  revalidateOnReconnect: true,\n  revalidateIfStale: true,\n  shouldRetryOnError: true,\n  // timeouts\n  errorRetryInterval: slowConnection ? 10000 : 5000,\n  focusThrottleInterval: 5 * 1000,\n  dedupingInterval: 2 * 1000,\n  loadingTimeout: slowConnection ? 5000 : 3000,\n  // providers\n  compare,\n  isPaused: () => false,\n  cache,\n  mutate,\n  fallback: {}\n},\n// use web preset by default\npreset);\nconst mergeConfigs = (a, b) => {\n  // Need to create a new object to avoid mutating the original here.\n  const v = mergeObjects(a, b);\n  // If two configs are provided, merge their `use` and `fallback` options.\n  if (b) {\n    const {\n      use: u1,\n      fallback: f1\n    } = a;\n    const {\n      use: u2,\n      fallback: f2\n    } = b;\n    if (u1 && u2) {\n      v.use = u1.concat(u2);\n    }\n    if (f1 && f2) {\n      v.fallback = mergeObjects(f1, f2);\n    }\n  }\n  return v;\n};\nconst SWRConfigContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nconst SWRConfig = props => {\n  const {\n    value\n  } = props;\n  const parentConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext);\n  const isFunctionalConfig = isFunction(value);\n  const config = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => isFunctionalConfig ? value(parentConfig) : value, [isFunctionalConfig, parentConfig, value]);\n  // Extend parent context values and middleware.\n  const extendedConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => isFunctionalConfig ? config : mergeConfigs(parentConfig, config), [isFunctionalConfig, parentConfig, config]);\n  // Should not use the inherited provider.\n  const provider = config && config.provider;\n  // initialize the cache only on first access.\n  const cacheContextRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(UNDEFINED);\n  if (provider && !cacheContextRef.current) {\n    cacheContextRef.current = initCache(provider(extendedConfig.cache || cache), config);\n  }\n  const cacheContext = cacheContextRef.current;\n  // Override the cache if a new provider is given.\n  if (cacheContext) {\n    extendedConfig.cache = cacheContext[0];\n    extendedConfig.mutate = cacheContext[1];\n  }\n  // Unsubscribe events.\n  useIsomorphicLayoutEffect(() => {\n    if (cacheContext) {\n      cacheContext[2] && cacheContext[2]();\n      return cacheContext[3];\n    }\n  }, []);\n  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SWRConfigContext.Provider, mergeObjects(props, {\n    value: extendedConfig\n  }));\n};\nconst INFINITE_PREFIX = '$inf$';\n\n// @ts-expect-error\nconst enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;\nconst use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];\nconst setupDevTools = () => {\n  if (enableDevtools) {\n    // @ts-expect-error\n    window.__SWR_DEVTOOLS_REACT__ = react__WEBPACK_IMPORTED_MODULE_0__;\n  }\n};\nconst normalize = args => {\n  return isFunction(args[1]) ? [args[0], args[1], args[2] || {}] : [args[0], null, (args[1] === null ? args[2] : args[1]) || {}];\n};\nconst useSWRConfig = () => {\n  return mergeObjects(defaultConfig, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext));\n};\nconst preload = (key_, fetcher) => {\n  const [key, fnArg] = serialize(key_);\n  const [,,, PRELOAD] = SWRGlobalState.get(cache);\n  // Prevent preload to be called multiple times before used.\n  if (PRELOAD[key]) return PRELOAD[key];\n  const req = fetcher(fnArg);\n  PRELOAD[key] = req;\n  return req;\n};\nconst middleware = useSWRNext => (key_, fetcher_, config) => {\n  // fetcher might be a sync function, so this should not be an async function\n  const fetcher = fetcher_ && ((...args) => {\n    const [key] = serialize(key_);\n    const [,,, PRELOAD] = SWRGlobalState.get(cache);\n    if (key.startsWith(INFINITE_PREFIX)) {\n      // we want the infinite fetcher to be called.\n      // handling of the PRELOAD cache happens there.\n      return fetcher_(...args);\n    }\n    const req = PRELOAD[key];\n    if (isUndefined(req)) return fetcher_(...args);\n    delete PRELOAD[key];\n    return req;\n  });\n  return useSWRNext(key_, fetcher, config);\n};\nconst BUILT_IN_MIDDLEWARE = use.concat(middleware);\n\n// It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\nconst withArgs = hook => {\n  return function useSWRArgs(...args) {\n    // Get the default and inherited configuration.\n    const fallbackConfig = useSWRConfig();\n    // Normalize arguments.\n    const [key, fn, _config] = normalize(args);\n    // Merge configurations.\n    const config = mergeConfigs(fallbackConfig, _config);\n    // Apply middleware\n    let next = hook;\n    const {\n      use\n    } = config;\n    const middleware = (use || []).concat(BUILT_IN_MIDDLEWARE);\n    for (let i = middleware.length; i--;) {\n      next = middleware[i](next);\n    }\n    return next(key, fn || config.fetcher || null, config);\n  };\n};\n\n// Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\nconst subscribeCallback = (key, callbacks, callback) => {\n  const keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n  keyedRevalidators.push(callback);\n  return () => {\n    const index = keyedRevalidators.indexOf(callback);\n    if (index >= 0) {\n      // O(1): faster than splice\n      keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n      keyedRevalidators.pop();\n    }\n  };\n};\n\n// Create a custom hook with a middleware\nconst withMiddleware = (useSWR, middleware) => {\n  return (...args) => {\n    const [key, fn, config] = normalize(args);\n    const uses = (config.use || []).concat(middleware);\n    return useSWR(key, fn, {\n      ...config,\n      use: uses\n    });\n  };\n};\nsetupDevTools();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dyL2Rpc3QvX2ludGVybmFsL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUg7O0FBRXJIO0FBQ0EsTUFBTVEsSUFBSSxHQUFHQSxDQUFBLEtBQUksQ0FBQyxDQUFDO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsU0FBUyxHQUFHLGlCQUFrQkQsSUFBSSxDQUFDLENBQUM7QUFDMUMsTUFBTUUsTUFBTSxHQUFHQyxNQUFNO0FBQ3JCLE1BQU1DLFdBQVcsR0FBSUMsQ0FBQyxJQUFHQSxDQUFDLEtBQUtKLFNBQVM7QUFDeEMsTUFBTUssVUFBVSxHQUFJRCxDQUFDLElBQUcsT0FBT0EsQ0FBQyxJQUFJLFVBQVU7QUFDOUMsTUFBTUUsWUFBWSxHQUFHQSxDQUFDQyxDQUFDLEVBQUVDLENBQUMsTUFBSTtFQUN0QixHQUFHRCxDQUFDO0VBQ0osR0FBR0M7QUFDUCxDQUFDLENBQUM7QUFDTixNQUFNQyxhQUFhLEdBQUlDLENBQUMsSUFBR0wsVUFBVSxDQUFDSyxDQUFDLENBQUNDLElBQUksQ0FBQzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxLQUFLLEdBQUcsSUFBSUMsT0FBTyxDQUFDLENBQUM7QUFDM0I7QUFDQSxJQUFJQyxPQUFPLEdBQUcsQ0FBQztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxVQUFVLEdBQUlDLEdBQUcsSUFBRztFQUN0QixNQUFNQyxJQUFJLEdBQUcsT0FBT0QsR0FBRztFQUN2QixNQUFNRSxXQUFXLEdBQUdGLEdBQUcsSUFBSUEsR0FBRyxDQUFDRSxXQUFXO0VBQzFDLE1BQU1DLE1BQU0sR0FBR0QsV0FBVyxJQUFJRSxJQUFJO0VBQ2xDLElBQUlDLE1BQU07RUFDVixJQUFJQyxLQUFLO0VBQ1QsSUFBSXJCLE1BQU0sQ0FBQ2UsR0FBRyxDQUFDLEtBQUtBLEdB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O0lBQ2QsTUFBTSxDQUFDcEMsR0FBRyxFQUFFa0csRUFBRSxFQUFFUSxNQUFNLENBQUMsR0FBR2dELFNBQVMsQ0FBQ3RILElBQUksQ0FBQztJQUN6QyxNQUFNOEksSUFBSSxHQUFHLENBQUN4RSxNQUFNLENBQUMyQixHQUFHLElBQUksRUFBRSxFQUFFSyxNQUFNLENBQUN1QixVQUFVLENBQUM7SUFDbEQsT0FBT2dCLE1BQU0sQ0FBQ2pMLEdBQUcsRUFBRWtHLEVBQUUsRUFBRTtNQUNuQixHQUFHUSxNQUFNO01BQ1QyQixHQUFHLEVBQUU2QztJQUNULENBQUMsQ0FBQztFQUNOLENBQUM7QUFDTCxDQUFDO0FBRUQxQixhQUFhLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NyYy8uL25vZGVfbW9kdWxlcy9zd3IvZGlzdC9faW50ZXJuYWwvaW5kZXgubWpzPzUwZWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vLCB1c2VSZWYsIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5cbi8vIFNoYXJlZCBzdGF0ZSBiZXR3ZWVuIHNlcnZlciBjb21wb25lbnRzIGFuZCBjbGllbnQgY29tcG9uZW50c1xuY29uc3Qgbm9vcCA9ICgpPT57fTtcbi8vIFVzaW5nIG5vb3AoKSBhcyB0aGUgdW5kZWZpbmVkIHZhbHVlIGFzIHVuZGVmaW5lZCBjYW4gYmUgcmVwbGFjZWRcbi8vIGJ5IHNvbWV0aGluZyBlbHNlLiBQcmV0dGllciBpZ25vcmUgYW5kIGV4dHJhIHBhcmVudGhlc2VzIGFyZSBuZWNlc3NhcnkgaGVyZVxuLy8gdG8gZW5zdXJlIHRoYXQgdHNjIGRvZXNuJ3QgcmVtb3ZlIHRoZSBfX05PSU5MSU5FX18gY29tbWVudC5cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgVU5ERUZJTkVEID0gLyojX19OT0lOTElORV9fKi8gbm9vcCgpO1xuY29uc3QgT0JKRUNUID0gT2JqZWN0O1xuY29uc3QgaXNVbmRlZmluZWQgPSAodik9PnYgPT09IFVOREVGSU5FRDtcbmNvbnN0IGlzRnVuY3Rpb24gPSAodik9PnR5cGVvZiB2ID09ICdmdW5jdGlvbic7XG5jb25zdCBtZXJnZU9iamVjdHMgPSAoYSwgYik9Pih7XG4gICAgICAgIC4uLmEsXG4gICAgICAgIC4uLmJcbiAgICB9KTtcbmNvbnN0IGlzUHJvbWlzZUxpa2UgPSAoeCk9PmlzRnVuY3Rpb24oeC50aGVuKTtcblxuLy8gdXNlIFdlYWtNYXAgdG8gc3RvcmUgdGhlIG9iamVjdC0+a2V5IG1hcHBpbmdcbi8vIHNvIHRoZSBvYmplY3RzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbi8vIFdlYWtNYXAgdXNlcyBhIGhhc2h0YWJsZSB1bmRlciB0aGUgaG9vZCwgc28gdGhlIGxvb2t1cFxuLy8gY29tcGxleGl0eSBpcyBhbG1vc3QgTygxKS5cbmNvbnN0IHRhYmxlID0gbmV3IFdlYWtNYXAoKTtcbi8vIGNvdW50ZXIgb2YgdGhlIGtleVxubGV0IGNvdW50ZXIgPSAwO1xuLy8gQSBzdGFibGUgaGFzaCBpbXBsZW1lbnRhdGlvbiB0aGF0IHN1cHBvcnRzOlxuLy8gLSBGYXN0IGFuZCBlbnN1cmVzIHVuaXF1ZSBoYXNoIHByb3BlcnRpZXNcbi8vIC0gSGFuZGxlcyB1bnNlcmlhbGl6YWJsZSB2YWx1ZXNcbi8vIC0gSGFuZGxlcyBvYmplY3Qga2V5IG9yZGVyaW5nXG4vLyAtIEdlbmVyYXRlcyBzaG9ydCByZXN1bHRzXG4vL1xuLy8gVGhpcyBpcyBub3QgYSBzZXJpYWxpemF0aW9uIGZ1bmN0aW9uLCBhbmQgdGhlIHJlc3VsdCBpcyBub3QgZ3VhcmFudGVlZCB0byBiZVxuLy8gcGFyc2FibGUuXG5jb25zdCBzdGFibGVIYXNoID0gKGFyZyk9PntcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGFyZztcbiAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGFyZyAmJiBhcmcuY29uc3RydWN0b3I7XG4gICAgY29uc3QgaXNEYXRlID0gY29uc3RydWN0b3IgPT0gRGF0ZTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBpbmRleDtcbiAgICBpZiAoT0JKRUNUKGFyZykgPT09IGFyZyAmJiAhaXNEYXRlICYmIGNvbnN0cnVjdG9yICE9IFJlZ0V4cCkge1xuICAgICAgICAvLyBPYmplY3QvZnVuY3Rpb24sIG5vdCBudWxsL2RhdGUvcmVnZXhwLiBVc2UgV2Vha01hcCB0byBzdG9yZSB0aGUgaWQgZmlyc3QuXG4gICAgICAgIC8vIElmIGl0J3MgYWxyZWFkeSBoYXNoZWQsIGRpcmVjdGx5IHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAgICByZXN1bHQgPSB0YWJsZS5nZXQoYXJnKTtcbiAgICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGhhc2ggZmlyc3QgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3Rpb24gYmVmb3JlIGVudGVyaW5nIHRoZVxuICAgICAgICAvLyByZWN1cnNpdmUgYHN0YWJsZUhhc2hgIGNhbGxzLlxuICAgICAgICAvLyBGb3Igb3RoZXIgb2JqZWN0cyBsaWtlIHNldCBhbmQgbWFwLCB3ZSB1c2UgdGhpcyBpZCBkaXJlY3RseSBhcyB0aGUgaGFzaC5cbiAgICAgICAgcmVzdWx0ID0gKytjb3VudGVyICsgJ34nO1xuICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT0gQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIEFycmF5LlxuICAgICAgICAgICAgcmVzdWx0ID0gJ0AnO1xuICAgICAgICAgICAgZm9yKGluZGV4ID0gMDsgaW5kZXggPCBhcmcubGVuZ3RoOyBpbmRleCsrKXtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RhYmxlSGFzaChhcmdbaW5kZXhdKSArICcsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYmxlLnNldChhcmcsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09IE9CSkVDVCkge1xuICAgICAgICAgICAgLy8gT2JqZWN0LCBzb3J0IGtleXMuXG4gICAgICAgICAgICByZXN1bHQgPSAnIyc7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT0JKRUNULmtleXMoYXJnKS5zb3J0KCk7XG4gICAgICAgICAgICB3aGlsZSghaXNVbmRlZmluZWQoaW5kZXggPSBrZXlzLnBvcCgpKSl7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChhcmdbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gaW5kZXggKyAnOicgKyBzdGFibGVIYXNoKGFyZ1tpbmRleF0pICsgJywnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYmxlLnNldChhcmcsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBpc0RhdGUgPyBhcmcudG9KU09OKCkgOiB0eXBlID09ICdzeW1ib2wnID8gYXJnLnRvU3RyaW5nKCkgOiB0eXBlID09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkoYXJnKSA6ICcnICsgYXJnO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gR2xvYmFsIHN0YXRlIHVzZWQgdG8gZGVkdXBsaWNhdGUgcmVxdWVzdHMgYW5kIHN0b3JlIGxpc3RlbmVyc1xuY29uc3QgU1dSR2xvYmFsU3RhdGUgPSBuZXcgV2Vha01hcCgpO1xuXG5jb25zdCBFTVBUWV9DQUNIRSA9IHt9O1xuY29uc3QgSU5JVElBTF9DQUNIRSA9IHt9O1xuY29uc3QgU1RSX1VOREVGSU5FRCA9ICd1bmRlZmluZWQnO1xuLy8gTk9URTogVXNlIHRoZSBmdW5jdGlvbiB0byBndWFyYW50ZWUgaXQncyByZS1ldmFsdWF0ZWQgYmV0d2VlbiBqc2RvbSBhbmQgbm9kZSBydW50aW1lIGZvciB0ZXN0cy5cbmNvbnN0IGlzV2luZG93RGVmaW5lZCA9IHR5cGVvZiB3aW5kb3cgIT0gU1RSX1VOREVGSU5FRDtcbmNvbnN0IGlzRG9jdW1lbnREZWZpbmVkID0gdHlwZW9mIGRvY3VtZW50ICE9IFNUUl9VTkRFRklORUQ7XG5jb25zdCBoYXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAoKT0+aXNXaW5kb3dEZWZpbmVkICYmIHR5cGVvZiB3aW5kb3dbJ3JlcXVlc3RBbmltYXRpb25GcmFtZSddICE9IFNUUl9VTkRFRklORUQ7XG5jb25zdCBjcmVhdGVDYWNoZUhlbHBlciA9IChjYWNoZSwga2V5KT0+e1xuICAgIGNvbnN0IHN0YXRlID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKTtcbiAgICByZXR1cm4gW1xuICAgICAgICAvLyBHZXR0ZXJcbiAgICAgICAgKCk9PiFpc1VuZGVmaW5lZChrZXkpICYmIGNhY2hlLmdldChrZXkpIHx8IEVNUFRZX0NBQ0hFLFxuICAgICAgICAvLyBTZXR0ZXJcbiAgICAgICAgKGluZm8pPT57XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgLy8gQmVmb3JlIHdyaXRpbmcgdG8gdGhlIHN0b3JlLCB3ZSBrZWVwIHRoZSB2YWx1ZSBpbiB0aGUgaW5pdGlhbCBjYWNoZVxuICAgICAgICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IHRoZXJlIHlldC5cbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gSU5JVElBTF9DQUNIRSkpIHtcbiAgICAgICAgICAgICAgICAgICAgSU5JVElBTF9DQUNIRVtrZXldID0gcHJldjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGVbNV0oa2V5LCBtZXJnZU9iamVjdHMocHJldiwgaW5mbyksIHByZXYgfHwgRU1QVFlfQ0FDSEUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBTdWJzY3JpYmVyXG4gICAgICAgIHN0YXRlWzZdLFxuICAgICAgICAvLyBHZXQgc2VydmVyIGNhY2hlIHNuYXBzaG90XG4gICAgICAgICgpPT57XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2FjaGUgd2FzIHVwZGF0ZWQgb24gdGhlIGNsaWVudCwgd2UgcmV0dXJuIHRoZSBzdG9yZWQgaW5pdGlhbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIElOSVRJQUxfQ0FDSEUpIHJldHVybiBJTklUSUFMX0NBQ0hFW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IGRvbmUgYW55IGNsaWVudC1zaWRlIHVwZGF0ZXMsIHdlIHJldHVybiB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiAhaXNVbmRlZmluZWQoa2V5KSAmJiBjYWNoZS5nZXQoa2V5KSB8fCBFTVBUWV9DQUNIRTtcbiAgICAgICAgfVxuICAgIF07XG59IC8vIGV4cG9ydCB7IFVOREVGSU5FRCwgT0JKRUNULCBpc1VuZGVmaW5lZCwgaXNGdW5jdGlvbiwgbWVyZ2VPYmplY3RzLCBpc1Byb21pc2VMaWtlIH1cbjtcblxuLyoqXG4gKiBEdWUgdG8gdGhlIGJ1ZyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02NzgwNzUsXG4gKiBpdCdzIG5vdCByZWxpYWJsZSB0byBkZXRlY3QgaWYgdGhlIGJyb3dzZXIgaXMgY3VycmVudGx5IG9ubGluZSBvciBvZmZsaW5lXG4gKiBiYXNlZCBvbiBgbmF2aWdhdG9yLm9uTGluZWAuXG4gKiBBcyBhIHdvcmthcm91bmQsIHdlIGFsd2F5cyBhc3N1bWUgaXQncyBvbmxpbmUgb24gdGhlIGZpcnN0IGxvYWQsIGFuZCBjaGFuZ2VcbiAqIHRoZSBzdGF0dXMgdXBvbiBgb25saW5lYCBvciBgb2ZmbGluZWAgZXZlbnRzLlxuICovIGxldCBvbmxpbmUgPSB0cnVlO1xuY29uc3QgaXNPbmxpbmUgPSAoKT0+b25saW5lO1xuLy8gRm9yIG5vZGUgYW5kIFJlYWN0IE5hdGl2ZSwgYGFkZC9yZW1vdmVFdmVudExpc3RlbmVyYCBkb2Vzbid0IGV4aXN0IG9uIHdpbmRvdy5cbmNvbnN0IFtvbldpbmRvd0V2ZW50LCBvZmZXaW5kb3dFdmVudF0gPSBpc1dpbmRvd0RlZmluZWQgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPyBbXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIuYmluZCh3aW5kb3cpLFxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQod2luZG93KVxuXSA6IFtcbiAgICBub29wLFxuICAgIG5vb3Bcbl07XG5jb25zdCBpc1Zpc2libGUgPSAoKT0+e1xuICAgIGNvbnN0IHZpc2liaWxpdHlTdGF0ZSA9IGlzRG9jdW1lbnREZWZpbmVkICYmIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZTtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQodmlzaWJpbGl0eVN0YXRlKSB8fCB2aXNpYmlsaXR5U3RhdGUgIT09ICdoaWRkZW4nO1xufTtcbmNvbnN0IGluaXRGb2N1cyA9IChjYWxsYmFjayk9PntcbiAgICAvLyBmb2N1cyByZXZhbGlkYXRlXG4gICAgaWYgKGlzRG9jdW1lbnREZWZpbmVkKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIG9uV2luZG93RXZlbnQoJ2ZvY3VzJywgY2FsbGJhY2spO1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICBpZiAoaXNEb2N1bWVudERlZmluZWQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgb2ZmV2luZG93RXZlbnQoJ2ZvY3VzJywgY2FsbGJhY2spO1xuICAgIH07XG59O1xuY29uc3QgaW5pdFJlY29ubmVjdCA9IChjYWxsYmFjayk9PntcbiAgICAvLyByZXZhbGlkYXRlIG9uIHJlY29ubmVjdGVkXG4gICAgY29uc3Qgb25PbmxpbmUgPSAoKT0+e1xuICAgICAgICBvbmxpbmUgPSB0cnVlO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH07XG4gICAgLy8gbm90aGluZyB0byByZXZhbGlkYXRlLCBqdXN0IHVwZGF0ZSB0aGUgc3RhdHVzXG4gICAgY29uc3Qgb25PZmZsaW5lID0gKCk9PntcbiAgICAgICAgb25saW5lID0gZmFsc2U7XG4gICAgfTtcbiAgICBvbldpbmRvd0V2ZW50KCdvbmxpbmUnLCBvbk9ubGluZSk7XG4gICAgb25XaW5kb3dFdmVudCgnb2ZmbGluZScsIG9uT2ZmbGluZSk7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIG9mZldpbmRvd0V2ZW50KCdvbmxpbmUnLCBvbk9ubGluZSk7XG4gICAgICAgIG9mZldpbmRvd0V2ZW50KCdvZmZsaW5lJywgb25PZmZsaW5lKTtcbiAgICB9O1xufTtcbmNvbnN0IHByZXNldCA9IHtcbiAgICBpc09ubGluZSxcbiAgICBpc1Zpc2libGVcbn07XG5jb25zdCBkZWZhdWx0Q29uZmlnT3B0aW9ucyA9IHtcbiAgICBpbml0Rm9jdXMsXG4gICAgaW5pdFJlY29ubmVjdFxufTtcblxuY29uc3QgSVNfUkVBQ1RfTEVHQUNZID0gIVJlYWN0LnVzZUlkO1xuY29uc3QgSVNfU0VSVkVSID0gIWlzV2luZG93RGVmaW5lZCB8fCAnRGVubycgaW4gd2luZG93O1xuLy8gUG9seWZpbGwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5jb25zdCByQUYgPSAoZik9Pmhhc1JlcXVlc3RBbmltYXRpb25GcmFtZSgpID8gd2luZG93WydyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXShmKSA6IHNldFRpbWVvdXQoZiwgMSk7XG4vLyBSZWFjdCBjdXJyZW50bHkgdGhyb3dzIGEgd2FybmluZyB3aGVuIHVzaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgc2VydmVyLlxuLy8gVG8gZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcbi8vIHVzZUxheW91dEVmZmVjdCBpbiB0aGUgYnJvd3Nlci5cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBJU19TRVJWRVIgPyB1c2VFZmZlY3QgOiB1c2VMYXlvdXRFZmZlY3Q7XG4vLyBUaGlzIGFzc2lnbm1lbnQgaXMgdG8gZXh0ZW5kIHRoZSBOYXZpZ2F0b3IgdHlwZSB0byB1c2UgZWZmZWN0aXZlVHlwZS5cbmNvbnN0IG5hdmlnYXRvckNvbm5lY3Rpb24gPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IuY29ubmVjdGlvbjtcbi8vIEFkanVzdCB0aGUgY29uZmlnIGJhc2VkIG9uIHNsb3cgY29ubmVjdGlvbiBzdGF0dXMgKDw9IDcwS2JwcykuXG5jb25zdCBzbG93Q29ubmVjdGlvbiA9ICFJU19TRVJWRVIgJiYgbmF2aWdhdG9yQ29ubmVjdGlvbiAmJiAoW1xuICAgICdzbG93LTJnJyxcbiAgICAnMmcnXG5dLmluY2x1ZGVzKG5hdmlnYXRvckNvbm5lY3Rpb24uZWZmZWN0aXZlVHlwZSkgfHwgbmF2aWdhdG9yQ29ubmVjdGlvbi5zYXZlRGF0YSk7XG5cbmNvbnN0IHNlcmlhbGl6ZSA9IChrZXkpPT57XG4gICAgaWYgKGlzRnVuY3Rpb24oa2V5KSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAga2V5ID0ga2V5KCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gZGVwZW5kZW5jaWVzIG5vdCByZWFkeVxuICAgICAgICAgICAga2V5ID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlIHRoZSBvcmlnaW5hbCBrZXkgYXMgdGhlIGFyZ3VtZW50IG9mIGZldGNoZXIuIFRoaXMgY2FuIGJlIGEgc3RyaW5nIG9yIGFuXG4gICAgLy8gYXJyYXkgb2YgdmFsdWVzLlxuICAgIGNvbnN0IGFyZ3MgPSBrZXk7XG4gICAgLy8gSWYga2V5IGlzIG5vdCBmYWxzeSwgb3Igbm90IGFuIGVtcHR5IGFycmF5LCBoYXNoIGl0LlxuICAgIGtleSA9IHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyBrZXkgOiAoQXJyYXkuaXNBcnJheShrZXkpID8ga2V5Lmxlbmd0aCA6IGtleSkgPyBzdGFibGVIYXNoKGtleSkgOiAnJztcbiAgICByZXR1cm4gW1xuICAgICAgICBrZXksXG4gICAgICAgIGFyZ3NcbiAgICBdO1xufTtcblxuLy8gR2xvYmFsIHRpbWVzdGFtcC5cbmxldCBfX3RpbWVzdGFtcCA9IDA7XG5jb25zdCBnZXRUaW1lc3RhbXAgPSAoKT0+KytfX3RpbWVzdGFtcDtcblxuY29uc3QgRk9DVVNfRVZFTlQgPSAwO1xuY29uc3QgUkVDT05ORUNUX0VWRU5UID0gMTtcbmNvbnN0IE1VVEFURV9FVkVOVCA9IDI7XG5jb25zdCBFUlJPUl9SRVZBTElEQVRFX0VWRU5UID0gMztcblxudmFyIGV2ZW50cyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBFUlJPUl9SRVZBTElEQVRFX0VWRU5UOiBFUlJPUl9SRVZBTElEQVRFX0VWRU5ULFxuICBGT0NVU19FVkVOVDogRk9DVVNfRVZFTlQsXG4gIE1VVEFURV9FVkVOVDogTVVUQVRFX0VWRU5ULFxuICBSRUNPTk5FQ1RfRVZFTlQ6IFJFQ09OTkVDVF9FVkVOVFxufTtcblxuYXN5bmMgZnVuY3Rpb24gaW50ZXJuYWxNdXRhdGUoLi4uYXJncykge1xuICAgIGNvbnN0IFtjYWNoZSwgX2tleSwgX2RhdGEsIF9vcHRzXSA9IGFyZ3M7XG4gICAgLy8gV2hlbiBwYXNzaW5nIGFzIGEgYm9vbGVhbiwgaXQncyBleHBsaWNpdGx5IHVzZWQgdG8gZGlzYWJsZS9lbmFibGVcbiAgICAvLyByZXZhbGlkYXRpb24uXG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlT2JqZWN0cyh7XG4gICAgICAgIHBvcHVsYXRlQ2FjaGU6IHRydWUsXG4gICAgICAgIHRocm93T25FcnJvcjogdHJ1ZVxuICAgIH0sIHR5cGVvZiBfb3B0cyA9PT0gJ2Jvb2xlYW4nID8ge1xuICAgICAgICByZXZhbGlkYXRlOiBfb3B0c1xuICAgIH0gOiBfb3B0cyB8fCB7fSk7XG4gICAgbGV0IHBvcHVsYXRlQ2FjaGUgPSBvcHRpb25zLnBvcHVsYXRlQ2FjaGU7XG4gICAgY29uc3Qgcm9sbGJhY2tPbkVycm9yT3B0aW9uID0gb3B0aW9ucy5yb2xsYmFja09uRXJyb3I7XG4gICAgbGV0IG9wdGltaXN0aWNEYXRhID0gb3B0aW9ucy5vcHRpbWlzdGljRGF0YTtcbiAgICBjb25zdCByb2xsYmFja09uRXJyb3IgPSAoZXJyb3IpPT57XG4gICAgICAgIHJldHVybiB0eXBlb2Ygcm9sbGJhY2tPbkVycm9yT3B0aW9uID09PSAnZnVuY3Rpb24nID8gcm9sbGJhY2tPbkVycm9yT3B0aW9uKGVycm9yKSA6IHJvbGxiYWNrT25FcnJvck9wdGlvbiAhPT0gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCB0aHJvd09uRXJyb3IgPSBvcHRpb25zLnRocm93T25FcnJvcjtcbiAgICAvLyBJZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIGEga2V5IGZpbHRlciwgcmV0dXJuIHRoZSBtdXRhdGlvbiByZXN1bHRzIGZvciBhbGxcbiAgICAvLyBmaWx0ZXJlZCBrZXlzLlxuICAgIGlmIChpc0Z1bmN0aW9uKF9rZXkpKSB7XG4gICAgICAgIGNvbnN0IGtleUZpbHRlciA9IF9rZXk7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRLZXlzID0gW107XG4gICAgICAgIGNvbnN0IGl0ID0gY2FjaGUua2V5cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBpdCl7XG4gICAgICAgICAgICBpZiAoLy8gU2tpcCB0aGUgc3BlY2lhbCB1c2VTV1JJbmZpbml0ZSBhbmQgdXNlU1dSU3Vic2NyaXB0aW9uIGtleXMuXG4gICAgICAgICAgICAhL15cXCQoaW5mfHN1YilcXCQvLnRlc3Qoa2V5KSAmJiBrZXlGaWx0ZXIoY2FjaGUuZ2V0KGtleSkuX2spKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZEtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChtYXRjaGVkS2V5cy5tYXAobXV0YXRlQnlLZXkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG11dGF0ZUJ5S2V5KF9rZXkpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIG11dGF0ZUJ5S2V5KF9rKSB7XG4gICAgICAgIC8vIFNlcmlhbGl6ZSBrZXlcbiAgICAgICAgY29uc3QgW2tleV0gPSBzZXJpYWxpemUoX2spO1xuICAgICAgICBpZiAoIWtleSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBbZ2V0LCBzZXRdID0gY3JlYXRlQ2FjaGVIZWxwZXIoY2FjaGUsIGtleSk7XG4gICAgICAgIGNvbnN0IFtFVkVOVF9SRVZBTElEQVRPUlMsIE1VVEFUSU9OLCBGRVRDSCwgUFJFTE9BRF0gPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpO1xuICAgICAgICBjb25zdCBzdGFydFJldmFsaWRhdGUgPSAoKT0+e1xuICAgICAgICAgICAgY29uc3QgcmV2YWxpZGF0b3JzID0gRVZFTlRfUkVWQUxJREFUT1JTW2tleV07XG4gICAgICAgICAgICBjb25zdCByZXZhbGlkYXRlID0gaXNGdW5jdGlvbihvcHRpb25zLnJldmFsaWRhdGUpID8gb3B0aW9ucy5yZXZhbGlkYXRlKGdldCgpLmRhdGEsIF9rKSA6IG9wdGlvbnMucmV2YWxpZGF0ZSAhPT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocmV2YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIEludmFsaWRhdGUgdGhlIGtleSBieSBkZWxldGluZyB0aGUgY29uY3VycmVudCByZXF1ZXN0IG1hcmtlcnMgc28gbmV3XG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdHMgd2lsbCBub3QgYmUgZGVkdXBlZC5cbiAgICAgICAgICAgICAgICBkZWxldGUgRkVUQ0hba2V5XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgUFJFTE9BRFtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChyZXZhbGlkYXRvcnMgJiYgcmV2YWxpZGF0b3JzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXZhbGlkYXRvcnNbMF0oTVVUQVRFX0VWRU5UKS50aGVuKCgpPT5nZXQoKS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0KCkuZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbmV3IGRhdGEgcHJvdmlkZWQsIHJldmFsaWRhdGUgdGhlIGtleSB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIC8vIFJldmFsaWRhdGUgYW5kIGJyb2FkY2FzdCBzdGF0ZS5cbiAgICAgICAgICAgIHJldHVybiBzdGFydFJldmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9IF9kYXRhO1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIC8vIFVwZGF0ZSBnbG9iYWwgdGltZXN0YW1wcy5cbiAgICAgICAgY29uc3QgYmVmb3JlTXV0YXRpb25UcyA9IGdldFRpbWVzdGFtcCgpO1xuICAgICAgICBNVVRBVElPTltrZXldID0gW1xuICAgICAgICAgICAgYmVmb3JlTXV0YXRpb25UcyxcbiAgICAgICAgICAgIDBcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgaGFzT3B0aW1pc3RpY0RhdGEgPSAhaXNVbmRlZmluZWQob3B0aW1pc3RpY0RhdGEpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICAvLyBgZGlzcGxheWVkRGF0YWAgaXMgdGhlIGN1cnJlbnQgdmFsdWUgb24gc2NyZWVuLiBJdCBjb3VsZCBiZSB0aGUgb3B0aW1pc3RpYyB2YWx1ZVxuICAgICAgICAvLyB0aGF0IGlzIGdvaW5nIHRvIGJlIG92ZXJyaWRkZW4gYnkgYSBgY29tbWl0dGVkRGF0YWAsIG9yIGdldCByZXZlcnRlZCBiYWNrLlxuICAgICAgICAvLyBgY29tbWl0dGVkRGF0YWAgaXMgdGhlIHZhbGlkYXRlZCB2YWx1ZSB0aGF0IGNvbWVzIGZyb20gYSBmZXRjaCBvciBtdXRhdGlvbi5cbiAgICAgICAgY29uc3QgZGlzcGxheWVkRGF0YSA9IHN0YXRlLmRhdGE7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREYXRhID0gc3RhdGUuX2M7XG4gICAgICAgIGNvbnN0IGNvbW1pdHRlZERhdGEgPSBpc1VuZGVmaW5lZChjdXJyZW50RGF0YSkgPyBkaXNwbGF5ZWREYXRhIDogY3VycmVudERhdGE7XG4gICAgICAgIC8vIERvIG9wdGltaXN0aWMgZGF0YSB1cGRhdGUuXG4gICAgICAgIGlmIChoYXNPcHRpbWlzdGljRGF0YSkge1xuICAgICAgICAgICAgb3B0aW1pc3RpY0RhdGEgPSBpc0Z1bmN0aW9uKG9wdGltaXN0aWNEYXRhKSA/IG9wdGltaXN0aWNEYXRhKGNvbW1pdHRlZERhdGEsIGRpc3BsYXllZERhdGEpIDogb3B0aW1pc3RpY0RhdGE7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIHNldCBvcHRpbWlzdGljIGRhdGEsIGJhY2t1cCB0aGUgY3VycmVudCBjb21taXR0ZWREYXRhIGRhdGEgaW4gYF9jYC5cbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgZGF0YTogb3B0aW1pc3RpY0RhdGEsXG4gICAgICAgICAgICAgICAgX2M6IGNvbW1pdHRlZERhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGRhdGEpKSB7XG4gICAgICAgICAgICAvLyBgZGF0YWAgaXMgYSBmdW5jdGlvbiwgY2FsbCBpdCBwYXNzaW5nIGN1cnJlbnQgY2FjaGUgdmFsdWUuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhKGNvbW1pdHRlZERhdGEpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgdGhyb3dzIGFuIGVycm9yIHN5bmNocm9ub3VzbHksIHdlIHNob3VsZG4ndCB1cGRhdGUgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGBkYXRhYCBpcyBhIHByb21pc2UvdGhlbmFibGUsIHJlc29sdmUgdGhlIGZpbmFsIGRhdGEgZmlyc3QuXG4gICAgICAgIGlmIChkYXRhICYmIGlzUHJvbWlzZUxpa2UoZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgbXV0YXRpb24gaXMgYXN5bmMsIHdlIG5lZWQgdG8gY2hlY2sgdGltZXN0YW1wcyB0b1xuICAgICAgICAgICAgLy8gYXZvaWQgcmFjZSBjb25kaXRpb25zLlxuICAgICAgICAgICAgZGF0YSA9IGF3YWl0IGRhdGEuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgb3RoZXIgbXV0YXRpb25zIGhhdmUgb2NjdXJyZWQgc2luY2Ugd2UndmUgc3RhcnRlZCB0aGlzIG11dGF0aW9uLlxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHJhY2Ugd2UgZG9uJ3QgdXBkYXRlIGNhY2hlIG9yIGJyb2FkY2FzdCB0aGUgY2hhbmdlLFxuICAgICAgICAgICAgLy8ganVzdCByZXR1cm4gdGhlIGRhdGEuXG4gICAgICAgICAgICBpZiAoYmVmb3JlTXV0YXRpb25UcyAhPT0gTVVUQVRJT05ba2V5XVswXSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yICYmIGhhc09wdGltaXN0aWNEYXRhICYmIHJvbGxiYWNrT25FcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAvLyBSb2xsYmFjay4gQWx3YXlzIHBvcHVsYXRlIHRoZSBjYWNoZSBpbiB0aGlzIGNhc2UgYnV0IHdpdGhvdXRcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm1pbmcgdGhlIGRhdGEuXG4gICAgICAgICAgICAgICAgcG9wdWxhdGVDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSB0byBiZSB0aGUgbGF0ZXN0IGNvbW1pdHRlZCBkYXRhLCBhbmQgY2xlYXIgdGhlIGBfY2AgdmFsdWUuXG4gICAgICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY29tbWl0dGVkRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgX2M6IFVOREVGSU5FRFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIHNob3VsZCB3cml0ZSBiYWNrIHRoZSBjYWNoZSBhZnRlciByZXF1ZXN0LlxuICAgICAgICBpZiAocG9wdWxhdGVDYWNoZSkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0aGUgcmVzdWx0IGludG8gZGF0YS5cbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwb3B1bGF0ZUNhY2hlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3B1bGF0ZUNhY2hlZERhdGEgPSBwb3B1bGF0ZUNhY2hlKGRhdGEsIGNvbW1pdHRlZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcG9wdWxhdGVDYWNoZWREYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFVOREVGSU5FRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jOiBVTkRFRklORURcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgY2FjaGVkIGRhdGEgYW5kIHJlc2V0IHRoZSBlcnJvciBpZiB0aGVyZSdzIG5vIGVycm9yLiBEYXRhIGNhbiBiZSBgdW5kZWZpbmVkYCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBVTkRFRklORUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBfYzogVU5ERUZJTkVEXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCB0aGUgdGltZXN0YW1wIHRvIG1hcmsgdGhlIG11dGF0aW9uIGhhcyBlbmRlZC5cbiAgICAgICAgTVVUQVRJT05ba2V5XVsxXSA9IGdldFRpbWVzdGFtcCgpO1xuICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgU1dSIEhvb2tzJyBpbnRlcm5hbCBzdGF0ZXM6XG4gICAgICAgIFByb21pc2UucmVzb2x2ZShzdGFydFJldmFsaWRhdGUoKSkudGhlbigoKT0+e1xuICAgICAgICAgICAgLy8gVGhlIG11dGF0aW9uIGFuZCByZXZhbGlkYXRpb24gYXJlIGVuZGVkLCB3ZSBjYW4gY2xlYXIgaXQgc2luY2UgdGhlIGRhdGEgaXNcbiAgICAgICAgICAgIC8vIG5vdCBhbiBvcHRpbWlzdGljIHZhbHVlIGFueW1vcmUuXG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgIF9jOiBVTkRFRklORURcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhyb3cgZXJyb3Igb3IgcmV0dXJuIGRhdGFcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59XG5cbmNvbnN0IHJldmFsaWRhdGVBbGxLZXlzID0gKHJldmFsaWRhdG9ycywgdHlwZSk9PntcbiAgICBmb3IoY29uc3Qga2V5IGluIHJldmFsaWRhdG9ycyl7XG4gICAgICAgIGlmIChyZXZhbGlkYXRvcnNba2V5XVswXSkgcmV2YWxpZGF0b3JzW2tleV1bMF0odHlwZSk7XG4gICAgfVxufTtcbmNvbnN0IGluaXRDYWNoZSA9IChwcm92aWRlciwgb3B0aW9ucyk9PntcbiAgICAvLyBUaGUgZ2xvYmFsIHN0YXRlIGZvciBhIHNwZWNpZmljIHByb3ZpZGVyIHdpbGwgYmUgdXNlZCB0byBkZWR1cGxpY2F0ZVxuICAgIC8vIHJlcXVlc3RzIGFuZCBzdG9yZSBsaXN0ZW5lcnMuIEFzIHdlbGwgYXMgYSBtdXRhdGUgZnVuY3Rpb24gdGhhdCBpcyBib3VuZCB0b1xuICAgIC8vIHRoZSBjYWNoZS5cbiAgICAvLyBUaGUgcHJvdmlkZXIncyBnbG9iYWwgc3RhdGUgbWlnaHQgYmUgYWxyZWFkeSBpbml0aWFsaXplZC4gTGV0J3MgdHJ5IHRvIGdldCB0aGVcbiAgICAvLyBnbG9iYWwgc3RhdGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlciBmaXJzdC5cbiAgICBpZiAoIVNXUkdsb2JhbFN0YXRlLmhhcyhwcm92aWRlcikpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IG1lcmdlT2JqZWN0cyhkZWZhdWx0Q29uZmlnT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZ2xvYmFsIHN0YXRlIGJvdW5kIHRvIHRoZSBwcm92aWRlciwgY3JlYXRlIGEgbmV3IG9uZSB3aXRoIHRoZVxuICAgICAgICAvLyBuZXcgbXV0YXRlIGZ1bmN0aW9uLlxuICAgICAgICBjb25zdCBFVkVOVF9SRVZBTElEQVRPUlMgPSB7fTtcbiAgICAgICAgY29uc3QgbXV0YXRlID0gaW50ZXJuYWxNdXRhdGUuYmluZChVTkRFRklORUQsIHByb3ZpZGVyKTtcbiAgICAgICAgbGV0IHVubW91bnQgPSBub29wO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zID0ge307XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZSA9IChrZXksIGNhbGxiYWNrKT0+e1xuICAgICAgICAgICAgY29uc3Qgc3VicyA9IHN1YnNjcmlwdGlvbnNba2V5XSB8fCBbXTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnNba2V5XSA9IHN1YnM7XG4gICAgICAgICAgICBzdWJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuICgpPT5zdWJzLnNwbGljZShzdWJzLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2V0dGVyID0gKGtleSwgdmFsdWUsIHByZXYpPT57XG4gICAgICAgICAgICBwcm92aWRlci5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBzdWJzID0gc3Vic2NyaXB0aW9uc1trZXldO1xuICAgICAgICAgICAgaWYgKHN1YnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIHN1YnMpe1xuICAgICAgICAgICAgICAgICAgICBmbih2YWx1ZSwgcHJldik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpbml0UHJvdmlkZXIgPSAoKT0+e1xuICAgICAgICAgICAgaWYgKCFTV1JHbG9iYWxTdGF0ZS5oYXMocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzdGF0ZSBpZiBpdCdzIG5ldywgb3IgaWYgdGhlIHByb3ZpZGVyIGhhcyBiZWVuIGV4dGVuZGVkLlxuICAgICAgICAgICAgICAgIFNXUkdsb2JhbFN0YXRlLnNldChwcm92aWRlciwgW1xuICAgICAgICAgICAgICAgICAgICBFVkVOVF9SRVZBTElEQVRPUlMsXG4gICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyLFxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBpZiAoIUlTX1NFUlZFUikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGxpc3RlbmluZyB0byB0aGUgbmF0aXZlIGV2ZW50cyBmb3IgYXV0byByZXZhbGlkYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBpbnRlbnRpb25hbGx5IHB1dCBhIGRlbGF5IChzZXRUaW1lb3V0KSBoZXJlIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZVxuICAgICAgICAgICAgICAgICAgICAvLyBmaXJlZCBhZnRlciBpbW1lZGlhdGUgSmF2YVNjcmlwdCBleGVjdXRpb25zLCB3aGljaCBjYW4gYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhY3QncyBzdGF0ZSB1cGRhdGVzLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGF2b2lkcyBzb21lIHVubmVjZXNzYXJ5IHJldmFsaWRhdGlvbnMgc3VjaCBhc1xuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL3N3ci9pc3N1ZXMvMTY4MC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsZWFzZUZvY3VzID0gb3B0cy5pbml0Rm9jdXMoc2V0VGltZW91dC5iaW5kKFVOREVGSU5FRCwgcmV2YWxpZGF0ZUFsbEtleXMuYmluZChVTkRFRklORUQsIEVWRU5UX1JFVkFMSURBVE9SUywgRk9DVVNfRVZFTlQpKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VSZWNvbm5lY3QgPSBvcHRzLmluaXRSZWNvbm5lY3Qoc2V0VGltZW91dC5iaW5kKFVOREVGSU5FRCwgcmV2YWxpZGF0ZUFsbEtleXMuYmluZChVTkRFRklORUQsIEVWRU5UX1JFVkFMSURBVE9SUywgUkVDT05ORUNUX0VWRU5UKSkpO1xuICAgICAgICAgICAgICAgICAgICB1bm1vdW50ID0gKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2VGb2N1cyAmJiByZWxlYXNlRm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2VSZWNvbm5lY3QgJiYgcmVsZWFzZVJlY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB1bi1tb3VudGluZywgd2UgbmVlZCB0byByZW1vdmUgdGhlIGNhY2hlIHByb3ZpZGVyIGZyb20gdGhlIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yYWdlIHRvbyBiZWNhdXNlIGl0J3MgYSBzaWRlLWVmZmVjdC4gT3RoZXJ3aXNlLCB3aGVuIHJlLW1vdW50aW5nIHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIG5vdCByZS1yZWdpc3RlciB0aG9zZSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICBTV1JHbG9iYWxTdGF0ZS5kZWxldGUocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaW5pdFByb3ZpZGVyKCk7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgcHJvdmlkZXIsIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZSBpdCBhbmQgc2V0dXAgRE9NIGV2ZW50c1xuICAgICAgICAvLyBsaXN0ZW5lcnMgZm9yIGBmb2N1c2AgYW5kIGByZWNvbm5lY3RgIGFjdGlvbnMuXG4gICAgICAgIC8vIFdlIG1pZ2h0IHdhbnQgdG8gaW5qZWN0IGFuIGV4dHJhIGxheWVyIG9uIHRvcCBvZiBgcHJvdmlkZXJgIGluIHRoZSBmdXR1cmUsXG4gICAgICAgIC8vIHN1Y2ggYXMga2V5IHNlcmlhbGl6YXRpb24sIGF1dG8gR0MsIGV0Yy5cbiAgICAgICAgLy8gRm9yIG5vdywgaXQncyBqdXN0IGEgYE1hcGAgaW50ZXJmYWNlIHdpdGhvdXQgYW55IG1vZGlmaWNhdGlvbnMuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgIGluaXRQcm92aWRlcixcbiAgICAgICAgICAgIHVubW91bnRcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIFNXUkdsb2JhbFN0YXRlLmdldChwcm92aWRlcilbNF1cbiAgICBdO1xufTtcblxuLy8gZXJyb3IgcmV0cnlcbmNvbnN0IG9uRXJyb3JSZXRyeSA9IChfLCBfXywgY29uZmlnLCByZXZhbGlkYXRlLCBvcHRzKT0+e1xuICAgIGNvbnN0IG1heFJldHJ5Q291bnQgPSBjb25maWcuZXJyb3JSZXRyeUNvdW50O1xuICAgIGNvbnN0IGN1cnJlbnRSZXRyeUNvdW50ID0gb3B0cy5yZXRyeUNvdW50O1xuICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICBjb25zdCB0aW1lb3V0ID0gfn4oKE1hdGgucmFuZG9tKCkgKyAwLjUpICogKDEgPDwgKGN1cnJlbnRSZXRyeUNvdW50IDwgOCA/IGN1cnJlbnRSZXRyeUNvdW50IDogOCkpKSAqIGNvbmZpZy5lcnJvclJldHJ5SW50ZXJ2YWw7XG4gICAgaWYgKCFpc1VuZGVmaW5lZChtYXhSZXRyeUNvdW50KSAmJiBjdXJyZW50UmV0cnlDb3VudCA+IG1heFJldHJ5Q291bnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KHJldmFsaWRhdGUsIHRpbWVvdXQsIG9wdHMpO1xufTtcbmNvbnN0IGNvbXBhcmUgPSAoY3VycmVudERhdGEsIG5ld0RhdGEpPT5zdGFibGVIYXNoKGN1cnJlbnREYXRhKSA9PSBzdGFibGVIYXNoKG5ld0RhdGEpO1xuLy8gRGVmYXVsdCBjYWNoZSBwcm92aWRlclxuY29uc3QgW2NhY2hlLCBtdXRhdGVdID0gaW5pdENhY2hlKG5ldyBNYXAoKSk7XG4vLyBEZWZhdWx0IGNvbmZpZ1xuY29uc3QgZGVmYXVsdENvbmZpZyA9IG1lcmdlT2JqZWN0cyh7XG4gICAgLy8gZXZlbnRzXG4gICAgb25Mb2FkaW5nU2xvdzogbm9vcCxcbiAgICBvblN1Y2Nlc3M6IG5vb3AsXG4gICAgb25FcnJvcjogbm9vcCxcbiAgICBvbkVycm9yUmV0cnksXG4gICAgb25EaXNjYXJkZWQ6IG5vb3AsXG4gICAgLy8gc3dpdGNoZXNcbiAgICByZXZhbGlkYXRlT25Gb2N1czogdHJ1ZSxcbiAgICByZXZhbGlkYXRlT25SZWNvbm5lY3Q6IHRydWUsXG4gICAgcmV2YWxpZGF0ZUlmU3RhbGU6IHRydWUsXG4gICAgc2hvdWxkUmV0cnlPbkVycm9yOiB0cnVlLFxuICAgIC8vIHRpbWVvdXRzXG4gICAgZXJyb3JSZXRyeUludGVydmFsOiBzbG93Q29ubmVjdGlvbiA/IDEwMDAwIDogNTAwMCxcbiAgICBmb2N1c1Rocm90dGxlSW50ZXJ2YWw6IDUgKiAxMDAwLFxuICAgIGRlZHVwaW5nSW50ZXJ2YWw6IDIgKiAxMDAwLFxuICAgIGxvYWRpbmdUaW1lb3V0OiBzbG93Q29ubmVjdGlvbiA/IDUwMDAgOiAzMDAwLFxuICAgIC8vIHByb3ZpZGVyc1xuICAgIGNvbXBhcmUsXG4gICAgaXNQYXVzZWQ6ICgpPT5mYWxzZSxcbiAgICBjYWNoZSxcbiAgICBtdXRhdGUsXG4gICAgZmFsbGJhY2s6IHt9XG59LCAvLyB1c2Ugd2ViIHByZXNldCBieSBkZWZhdWx0XG5wcmVzZXQpO1xuXG5jb25zdCBtZXJnZUNvbmZpZ3MgPSAoYSwgYik9PntcbiAgICAvLyBOZWVkIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3QgdG8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIGhlcmUuXG4gICAgY29uc3QgdiA9IG1lcmdlT2JqZWN0cyhhLCBiKTtcbiAgICAvLyBJZiB0d28gY29uZmlncyBhcmUgcHJvdmlkZWQsIG1lcmdlIHRoZWlyIGB1c2VgIGFuZCBgZmFsbGJhY2tgIG9wdGlvbnMuXG4gICAgaWYgKGIpIHtcbiAgICAgICAgY29uc3QgeyB1c2U6IHUxLCBmYWxsYmFjazogZjEgfSA9IGE7XG4gICAgICAgIGNvbnN0IHsgdXNlOiB1MiwgZmFsbGJhY2s6IGYyIH0gPSBiO1xuICAgICAgICBpZiAodTEgJiYgdTIpIHtcbiAgICAgICAgICAgIHYudXNlID0gdTEuY29uY2F0KHUyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZjEgJiYgZjIpIHtcbiAgICAgICAgICAgIHYuZmFsbGJhY2sgPSBtZXJnZU9iamVjdHMoZjEsIGYyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbn07XG5cbmNvbnN0IFNXUkNvbmZpZ0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcbmNvbnN0IFNXUkNvbmZpZyA9IChwcm9wcyk9PntcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBwcm9wcztcbiAgICBjb25zdCBwYXJlbnRDb25maWcgPSB1c2VDb250ZXh0KFNXUkNvbmZpZ0NvbnRleHQpO1xuICAgIGNvbnN0IGlzRnVuY3Rpb25hbENvbmZpZyA9IGlzRnVuY3Rpb24odmFsdWUpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHVzZU1lbW8oKCk9PmlzRnVuY3Rpb25hbENvbmZpZyA/IHZhbHVlKHBhcmVudENvbmZpZykgOiB2YWx1ZSwgW1xuICAgICAgICBpc0Z1bmN0aW9uYWxDb25maWcsXG4gICAgICAgIHBhcmVudENvbmZpZyxcbiAgICAgICAgdmFsdWVcbiAgICBdKTtcbiAgICAvLyBFeHRlbmQgcGFyZW50IGNvbnRleHQgdmFsdWVzIGFuZCBtaWRkbGV3YXJlLlxuICAgIGNvbnN0IGV4dGVuZGVkQ29uZmlnID0gdXNlTWVtbygoKT0+aXNGdW5jdGlvbmFsQ29uZmlnID8gY29uZmlnIDogbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSwgW1xuICAgICAgICBpc0Z1bmN0aW9uYWxDb25maWcsXG4gICAgICAgIHBhcmVudENvbmZpZyxcbiAgICAgICAgY29uZmlnXG4gICAgXSk7XG4gICAgLy8gU2hvdWxkIG5vdCB1c2UgdGhlIGluaGVyaXRlZCBwcm92aWRlci5cbiAgICBjb25zdCBwcm92aWRlciA9IGNvbmZpZyAmJiBjb25maWcucHJvdmlkZXI7XG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgY2FjaGUgb25seSBvbiBmaXJzdCBhY2Nlc3MuXG4gICAgY29uc3QgY2FjaGVDb250ZXh0UmVmID0gdXNlUmVmKFVOREVGSU5FRCk7XG4gICAgaWYgKHByb3ZpZGVyICYmICFjYWNoZUNvbnRleHRSZWYuY3VycmVudCkge1xuICAgICAgICBjYWNoZUNvbnRleHRSZWYuY3VycmVudCA9IGluaXRDYWNoZShwcm92aWRlcihleHRlbmRlZENvbmZpZy5jYWNoZSB8fCBjYWNoZSksIGNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlQ29udGV4dCA9IGNhY2hlQ29udGV4dFJlZi5jdXJyZW50O1xuICAgIC8vIE92ZXJyaWRlIHRoZSBjYWNoZSBpZiBhIG5ldyBwcm92aWRlciBpcyBnaXZlbi5cbiAgICBpZiAoY2FjaGVDb250ZXh0KSB7XG4gICAgICAgIGV4dGVuZGVkQ29uZmlnLmNhY2hlID0gY2FjaGVDb250ZXh0WzBdO1xuICAgICAgICBleHRlbmRlZENvbmZpZy5tdXRhdGUgPSBjYWNoZUNvbnRleHRbMV07XG4gICAgfVxuICAgIC8vIFVuc3Vic2NyaWJlIGV2ZW50cy5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChjYWNoZUNvbnRleHQpIHtcbiAgICAgICAgICAgIGNhY2hlQ29udGV4dFsyXSAmJiBjYWNoZUNvbnRleHRbMl0oKTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZUNvbnRleHRbM107XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoU1dSQ29uZmlnQ29udGV4dC5Qcm92aWRlciwgbWVyZ2VPYmplY3RzKHByb3BzLCB7XG4gICAgICAgIHZhbHVlOiBleHRlbmRlZENvbmZpZ1xuICAgIH0pKTtcbn07XG5cbmNvbnN0IElORklOSVRFX1BSRUZJWCA9ICckaW5mJCc7XG5cbi8vIEB0cy1leHBlY3QtZXJyb3JcbmNvbnN0IGVuYWJsZURldnRvb2xzID0gaXNXaW5kb3dEZWZpbmVkICYmIHdpbmRvdy5fX1NXUl9ERVZUT09MU19VU0VfXztcbmNvbnN0IHVzZSA9IGVuYWJsZURldnRvb2xzID8gd2luZG93Ll9fU1dSX0RFVlRPT0xTX1VTRV9fIDogW107XG5jb25zdCBzZXR1cERldlRvb2xzID0gKCk9PntcbiAgICBpZiAoZW5hYmxlRGV2dG9vbHMpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICB3aW5kb3cuX19TV1JfREVWVE9PTFNfUkVBQ1RfXyA9IFJlYWN0O1xuICAgIH1cbn07XG5cbmNvbnN0IG5vcm1hbGl6ZSA9IChhcmdzKT0+e1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGFyZ3NbMV0pID8gW1xuICAgICAgICBhcmdzWzBdLFxuICAgICAgICBhcmdzWzFdLFxuICAgICAgICBhcmdzWzJdIHx8IHt9XG4gICAgXSA6IFtcbiAgICAgICAgYXJnc1swXSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgKGFyZ3NbMV0gPT09IG51bGwgPyBhcmdzWzJdIDogYXJnc1sxXSkgfHwge31cbiAgICBdO1xufTtcblxuY29uc3QgdXNlU1dSQ29uZmlnID0gKCk9PntcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RzKGRlZmF1bHRDb25maWcsIHVzZUNvbnRleHQoU1dSQ29uZmlnQ29udGV4dCkpO1xufTtcblxuY29uc3QgcHJlbG9hZCA9IChrZXlfLCBmZXRjaGVyKT0+e1xuICAgIGNvbnN0IFtrZXksIGZuQXJnXSA9IHNlcmlhbGl6ZShrZXlfKTtcbiAgICBjb25zdCBbLCAsICwgUFJFTE9BRF0gPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpO1xuICAgIC8vIFByZXZlbnQgcHJlbG9hZCB0byBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgYmVmb3JlIHVzZWQuXG4gICAgaWYgKFBSRUxPQURba2V5XSkgcmV0dXJuIFBSRUxPQURba2V5XTtcbiAgICBjb25zdCByZXEgPSBmZXRjaGVyKGZuQXJnKTtcbiAgICBQUkVMT0FEW2tleV0gPSByZXE7XG4gICAgcmV0dXJuIHJlcTtcbn07XG5jb25zdCBtaWRkbGV3YXJlID0gKHVzZVNXUk5leHQpPT4oa2V5XywgZmV0Y2hlcl8sIGNvbmZpZyk9PntcbiAgICAgICAgLy8gZmV0Y2hlciBtaWdodCBiZSBhIHN5bmMgZnVuY3Rpb24sIHNvIHRoaXMgc2hvdWxkIG5vdCBiZSBhbiBhc3luYyBmdW5jdGlvblxuICAgICAgICBjb25zdCBmZXRjaGVyID0gZmV0Y2hlcl8gJiYgKCguLi5hcmdzKT0+e1xuICAgICAgICAgICAgY29uc3QgW2tleV0gPSBzZXJpYWxpemUoa2V5Xyk7XG4gICAgICAgICAgICBjb25zdCBbLCAsICwgUFJFTE9BRF0gPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpO1xuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKElORklOSVRFX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRoZSBpbmZpbml0ZSBmZXRjaGVyIHRvIGJlIGNhbGxlZC5cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGluZyBvZiB0aGUgUFJFTE9BRCBjYWNoZSBoYXBwZW5zIHRoZXJlLlxuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaGVyXyguLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IFBSRUxPQURba2V5XTtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChyZXEpKSByZXR1cm4gZmV0Y2hlcl8oLi4uYXJncyk7XG4gICAgICAgICAgICBkZWxldGUgUFJFTE9BRFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIHJlcTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1c2VTV1JOZXh0KGtleV8sIGZldGNoZXIsIGNvbmZpZyk7XG4gICAgfTtcblxuY29uc3QgQlVJTFRfSU5fTUlERExFV0FSRSA9IHVzZS5jb25jYXQobWlkZGxld2FyZSk7XG5cbi8vIEl0J3MgdHJpY2t5IHRvIHBhc3MgZ2VuZXJpYyB0eXBlcyBhcyBwYXJhbWV0ZXJzLCBzbyB3ZSBqdXN0IGRpcmVjdGx5IG92ZXJyaWRlXG4vLyB0aGUgdHlwZXMgaGVyZS5cbmNvbnN0IHdpdGhBcmdzID0gKGhvb2spPT57XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVzZVNXUkFyZ3MoLi4uYXJncykge1xuICAgICAgICAvLyBHZXQgdGhlIGRlZmF1bHQgYW5kIGluaGVyaXRlZCBjb25maWd1cmF0aW9uLlxuICAgICAgICBjb25zdCBmYWxsYmFja0NvbmZpZyA9IHVzZVNXUkNvbmZpZygpO1xuICAgICAgICAvLyBOb3JtYWxpemUgYXJndW1lbnRzLlxuICAgICAgICBjb25zdCBba2V5LCBmbiwgX2NvbmZpZ10gPSBub3JtYWxpemUoYXJncyk7XG4gICAgICAgIC8vIE1lcmdlIGNvbmZpZ3VyYXRpb25zLlxuICAgICAgICBjb25zdCBjb25maWcgPSBtZXJnZUNvbmZpZ3MoZmFsbGJhY2tDb25maWcsIF9jb25maWcpO1xuICAgICAgICAvLyBBcHBseSBtaWRkbGV3YXJlXG4gICAgICAgIGxldCBuZXh0ID0gaG9vaztcbiAgICAgICAgY29uc3QgeyB1c2UgfSA9IGNvbmZpZztcbiAgICAgICAgY29uc3QgbWlkZGxld2FyZSA9ICh1c2UgfHwgW10pLmNvbmNhdChCVUlMVF9JTl9NSURETEVXQVJFKTtcbiAgICAgICAgZm9yKGxldCBpID0gbWlkZGxld2FyZS5sZW5ndGg7IGktLTspe1xuICAgICAgICAgICAgbmV4dCA9IG1pZGRsZXdhcmVbaV0obmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQoa2V5LCBmbiB8fCBjb25maWcuZmV0Y2hlciB8fCBudWxsLCBjb25maWcpO1xuICAgIH07XG59O1xuXG4vLyBBZGQgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBhIGxpc3Qgb2Yga2V5ZWQgY2FsbGJhY2sgZnVuY3Rpb25zIGFuZCByZXR1cm5cbi8vIHRoZSB1bnN1YnNjcmliZSBmdW5jdGlvbi5cbmNvbnN0IHN1YnNjcmliZUNhbGxiYWNrID0gKGtleSwgY2FsbGJhY2tzLCBjYWxsYmFjayk9PntcbiAgICBjb25zdCBrZXllZFJldmFsaWRhdG9ycyA9IGNhbGxiYWNrc1trZXldIHx8IChjYWxsYmFja3Nba2V5XSA9IFtdKTtcbiAgICBrZXllZFJldmFsaWRhdG9ycy5wdXNoKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgY29uc3QgaW5kZXggPSBrZXllZFJldmFsaWRhdG9ycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIC8vIE8oMSk6IGZhc3RlciB0aGFuIHNwbGljZVxuICAgICAgICAgICAga2V5ZWRSZXZhbGlkYXRvcnNbaW5kZXhdID0ga2V5ZWRSZXZhbGlkYXRvcnNba2V5ZWRSZXZhbGlkYXRvcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBrZXllZFJldmFsaWRhdG9ycy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG4vLyBDcmVhdGUgYSBjdXN0b20gaG9vayB3aXRoIGEgbWlkZGxld2FyZVxuY29uc3Qgd2l0aE1pZGRsZXdhcmUgPSAodXNlU1dSLCBtaWRkbGV3YXJlKT0+e1xuICAgIHJldHVybiAoLi4uYXJncyk9PntcbiAgICAgICAgY29uc3QgW2tleSwgZm4sIGNvbmZpZ10gPSBub3JtYWxpemUoYXJncyk7XG4gICAgICAgIGNvbnN0IHVzZXMgPSAoY29uZmlnLnVzZSB8fCBbXSkuY29uY2F0KG1pZGRsZXdhcmUpO1xuICAgICAgICByZXR1cm4gdXNlU1dSKGtleSwgZm4sIHtcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgIHVzZTogdXNlc1xuICAgICAgICB9KTtcbiAgICB9O1xufTtcblxuc2V0dXBEZXZUb29scygpO1xuXG5leHBvcnQgeyBJTkZJTklURV9QUkVGSVgsIElTX1JFQUNUX0xFR0FDWSwgSVNfU0VSVkVSLCBPQkpFQ1QsIFNXUkNvbmZpZywgU1dSR2xvYmFsU3RhdGUsIFVOREVGSU5FRCwgY2FjaGUsIGNvbXBhcmUsIGNyZWF0ZUNhY2hlSGVscGVyLCBkZWZhdWx0Q29uZmlnLCBkZWZhdWx0Q29uZmlnT3B0aW9ucywgZ2V0VGltZXN0YW1wLCBoYXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGluaXRDYWNoZSwgaW50ZXJuYWxNdXRhdGUsIGlzRG9jdW1lbnREZWZpbmVkLCBpc0Z1bmN0aW9uLCBpc1Byb21pc2VMaWtlLCBpc1VuZGVmaW5lZCwgaXNXaW5kb3dEZWZpbmVkLCBtZXJnZUNvbmZpZ3MsIG1lcmdlT2JqZWN0cywgbXV0YXRlLCBub29wLCBub3JtYWxpemUsIHByZWxvYWQsIHByZXNldCwgckFGLCBldmVudHMgYXMgcmV2YWxpZGF0ZUV2ZW50cywgc2VyaWFsaXplLCBzbG93Q29ubmVjdGlvbiwgc3RhYmxlSGFzaCwgc3Vic2NyaWJlQ2FsbGJhY2ssIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QsIHVzZVNXUkNvbmZpZywgd2l0aEFyZ3MsIHdpdGhNaWRkbGV3YXJlIH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJjcmVhdGVFbGVtZW50Iiwibm9vcCIsIlVOREVGSU5FRCIsIk9CSkVDVCIsIk9iamVjdCIsImlzVW5kZWZpbmVkIiwidiIsImlzRnVuY3Rpb24iLCJtZXJnZU9iamVjdHMiLCJhIiwiYiIsImlzUHJvbWlzZUxpa2UiLCJ4IiwidGhlbiIsInRhYmxlIiwiV2Vha01hcCIsImNvdW50ZXIiLCJzdGFibGVIYXNoIiwiYXJnIiwidHlwZSIsImNvbnN0cnVjdG9yIiwiaXNEYXRlIiwiRGF0ZSIsInJlc3VsdCIsImluZGV4IiwiUmVnRXhwIiwiZ2V0Iiwic2V0IiwiQXJyYXkiLCJsZW5ndGgiLCJrZXlzIiwic29ydCIsInBvcCIsInRvSlNPTiIsInRvU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsIlNXUkdsb2JhbFN0YXRlIiwiRU1QVFlfQ0FDSEUiLCJJTklUSUFMX0NBQ0hFIiwiU1RSX1VOREVGSU5FRCIsImlzV2luZG93RGVmaW5lZCIsImlzRG9jdW1lbnREZWZpbmVkIiwiZG9jdW1lbnQiLCJoYXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3aW5kb3ciLCJjcmVhdGVDYWNoZUhlbHBlciIsImNhY2hlIiwia2V5Iiwic3RhdGUiLCJpbmZvIiwicHJldiIsIm9ubGluZSIsImlzT25saW5lIiwib25XaW5kb3dFdmVudCIsIm9mZldpbmRvd0V2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImJpbmQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaXNWaXNpYmxlIiwidmlzaWJpbGl0eVN0YXRlIiwiaW5pdEZvY3VzIiwiY2FsbGJhY2siLCJpbml0UmVjb25uZWN0Iiwib25PbmxpbmUiLCJvbk9mZmxpbmUiLCJwcmVzZXQiLCJkZWZhdWx0Q29uZmlnT3B0aW9ucyIsIklTX1JFQUNUX0xFR0FDWSIsInVzZUlkIiwiSVNfU0VSVkVSIiwickFGIiwiZiIsInNldFRpbWVvdXQiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwibmF2aWdhdG9yQ29ubmVjdGlvbiIsIm5hdmlnYXRvciIsImNvbm5lY3Rpb24iLCJzbG93Q29ubmVjdGlvbiIsImluY2x1ZGVzIiwiZWZmZWN0aXZlVHlwZSIsInNhdmVEYXRhIiwic2VyaWFsaXplIiwiZXJyIiwiYXJncyIsImlzQXJyYXkiLCJfX3RpbWVzdGFtcCIsImdldFRpbWVzdGFtcCIsIkZPQ1VTX0VWRU5UIiwiUkVDT05ORUNUX0VWRU5UIiwiTVVUQVRFX0VWRU5UIiwiRVJST1JfUkVWQUxJREFURV9FVkVOVCIsImV2ZW50cyIsIl9fcHJvdG9fXyIsImludGVybmFsTXV0YXRlIiwiX2tleSIsIl9kYXRhIiwiX29wdHMiLCJvcHRpb25zIiwicG9wdWxhdGVDYWNoZSIsInRocm93T25FcnJvciIsInJldmFsaWRhdGUiLCJyb2xsYmFja09uRXJyb3JPcHRpb24iLCJyb2xsYmFja09uRXJyb3IiLCJvcHRpbWlzdGljRGF0YSIsImVycm9yIiwia2V5RmlsdGVyIiwibWF0Y2hlZEtleXMiLCJpdCIsInRlc3QiLCJfayIsInB1c2giLCJQcm9taXNlIiwiYWxsIiwibWFwIiwibXV0YXRlQnlLZXkiLCJFVkVOVF9SRVZBTElEQVRPUlMiLCJNVVRBVElPTiIsIkZFVENIIiwiUFJFTE9BRCIsInN0YXJ0UmV2YWxpZGF0ZSIsInJldmFsaWRhdG9ycyIsImRhdGEiLCJiZWZvcmVNdXRhdGlvblRzIiwiaGFzT3B0aW1pc3RpY0RhdGEiLCJkaXNwbGF5ZWREYXRhIiwiY3VycmVudERhdGEiLCJfYyIsImNvbW1pdHRlZERhdGEiLCJjYXRjaCIsInBvcHVsYXRlQ2FjaGVkRGF0YSIsInJlc29sdmUiLCJyZXZhbGlkYXRlQWxsS2V5cyIsImluaXRDYWNoZSIsInByb3ZpZGVyIiwiaGFzIiwib3B0cyIsIm11dGF0ZSIsInVubW91bnQiLCJzdWJzY3JpcHRpb25zIiwic3Vic2NyaWJlIiwic3VicyIsInNwbGljZSIsImluZGV4T2YiLCJzZXR0ZXIiLCJ2YWx1ZSIsImZuIiwiaW5pdFByb3ZpZGVyIiwicmVsZWFzZUZvY3VzIiwicmVsZWFzZVJlY29ubmVjdCIsImRlbGV0ZSIsIm9uRXJyb3JSZXRyeSIsIl8iLCJfXyIsImNvbmZpZyIsIm1heFJldHJ5Q291bnQiLCJlcnJvclJldHJ5Q291bnQiLCJjdXJyZW50UmV0cnlDb3VudCIsInJldHJ5Q291bnQiLCJ0aW1lb3V0IiwiTWF0aCIsInJhbmRvbSIsImVycm9yUmV0cnlJbnRlcnZhbCIsImNvbXBhcmUiLCJuZXdEYXRhIiwiTWFwIiwiZGVmYXVsdENvbmZpZyIsIm9uTG9hZGluZ1Nsb3ciLCJvblN1Y2Nlc3MiLCJvbkVycm9yIiwib25EaXNjYXJkZWQiLCJyZXZhbGlkYXRlT25Gb2N1cyIsInJldmFsaWRhdGVPblJlY29ubmVjdCIsInJldmFsaWRhdGVJZlN0YWxlIiwic2hvdWxkUmV0cnlPbkVycm9yIiwiZm9jdXNUaHJvdHRsZUludGVydmFsIiwiZGVkdXBpbmdJbnRlcnZhbCIsImxvYWRpbmdUaW1lb3V0IiwiaXNQYXVzZWQiLCJmYWxsYmFjayIsIm1lcmdlQ29uZmlncyIsInVzZSIsInUxIiwiZjEiLCJ1MiIsImYyIiwiY29uY2F0IiwiU1dSQ29uZmlnQ29udGV4dCIsIlNXUkNvbmZpZyIsInByb3BzIiwicGFyZW50Q29uZmlnIiwiaXNGdW5jdGlvbmFsQ29uZmlnIiwiZXh0ZW5kZWRDb25maWciLCJjYWNoZUNvbnRleHRSZWYiLCJjdXJyZW50IiwiY2FjaGVDb250ZXh0IiwiUHJvdmlkZXIiLCJJTkZJTklURV9QUkVGSVgiLCJlbmFibGVEZXZ0b29scyIsIl9fU1dSX0RFVlRPT0xTX1VTRV9fIiwic2V0dXBEZXZUb29scyIsIl9fU1dSX0RFVlRPT0xTX1JFQUNUX18iLCJub3JtYWxpemUiLCJ1c2VTV1JDb25maWciLCJwcmVsb2FkIiwia2V5XyIsImZldGNoZXIiLCJmbkFyZyIsInJlcSIsIm1pZGRsZXdhcmUiLCJ1c2VTV1JOZXh0IiwiZmV0Y2hlcl8iLCJzdGFydHNXaXRoIiwiQlVJTFRfSU5fTUlERExFV0FSRSIsIndpdGhBcmdzIiwiaG9vayIsInVzZVNXUkFyZ3MiLCJmYWxsYmFja0NvbmZpZyIsIl9jb25maWciLCJuZXh0IiwiaSIsInN1YnNjcmliZUNhbGxiYWNrIiwiY2FsbGJhY2tzIiwia2V5ZWRSZXZhbGlkYXRvcnMiLCJ3aXRoTWlkZGxld2FyZSIsInVzZVNXUiIsInVzZXMiLCJyZXZhbGlkYXRlRXZlbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swr/dist/_internal/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/swr/dist/core/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/swr/dist/core/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SWRConfig: () => (/* binding */ SWRConfig),\n/* harmony export */   \"default\": () => (/* binding */ useSWR),\n/* harmony export */   mutate: () => (/* reexport safe */ swr_internal__WEBPACK_IMPORTED_MODULE_3__.mutate),\n/* harmony export */   preload: () => (/* reexport safe */ swr_internal__WEBPACK_IMPORTED_MODULE_3__.preload),\n/* harmony export */   unstable_serialize: () => (/* binding */ unstable_serialize),\n/* harmony export */   useSWRConfig: () => (/* reexport safe */ swr_internal__WEBPACK_IMPORTED_MODULE_3__.useSWRConfig)\n/* harmony export */ });\n/* harmony import */ var client_only__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! client-only */ \"(ssr)/./node_modules/next/dist/compiled/client-only/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var swr_internal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! swr/_internal */ \"(ssr)/./node_modules/swr/dist/_internal/index.mjs\");\n\n\n\n\n\nconst unstable_serialize = key => (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.serialize)(key)[0];\n\n/// <reference types=\"react/experimental\" />\nconst use = react__WEBPACK_IMPORTED_MODULE_1__.use || (promise => {\n  if (promise.status === 'pending') {\n    throw promise;\n  } else if (promise.status === 'fulfilled') {\n    return promise.value;\n  } else if (promise.status === 'rejected') {\n    throw promise.reason;\n  } else {\n    promise.status = 'pending';\n    promise.then(v => {\n      promise.status = 'fulfilled';\n      promise.value = v;\n    }, e => {\n      promise.status = 'rejected';\n      promise.reason = e;\n    });\n    throw promise;\n  }\n});\nconst WITH_DEDUPE = {\n  dedupe: true\n};\nconst useSWRHandler = (_key, fetcher, config) => {\n  const {\n    cache,\n    compare,\n    suspense,\n    fallbackData,\n    revalidateOnMount,\n    revalidateIfStale,\n    refreshInterval,\n    refreshWhenHidden,\n    refreshWhenOffline,\n    keepPreviousData\n  } = config;\n  const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = swr_internal__WEBPACK_IMPORTED_MODULE_3__.SWRGlobalState.get(cache);\n  // `key` is the identifier of the SWR internal state,\n  // `fnArg` is the argument/arguments parsed from the key, which will be passed\n  // to the fetcher.\n  // All of them are derived from `_key`.\n  const [key, fnArg] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.serialize)(_key);\n  // If it's the initial render of this hook.\n  const initialMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n  // If the hook is unmounted already. This will be used to prevent some effects\n  // to be called after unmounting.\n  const unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n  // Refs to keep the key and config.\n  const keyRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(key);\n  const fetcherRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(fetcher);\n  const configRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(config);\n  const getConfig = () => configRef.current;\n  const isActive = () => getConfig().isVisible() && getConfig().isOnline();\n  const [getCache, setCache, subscribeCache, getInitialCache] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.createCacheHelper)(cache, key);\n  const stateDependencies = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({}).current;\n  const fallback = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(fallbackData) ? config.fallback[key] : fallbackData;\n  const isEqual = (prev, current) => {\n    for (const _ in stateDependencies) {\n      const t = _;\n      if (t === 'data') {\n        if (!compare(prev[t], current[t])) {\n          if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(prev[t])) {\n            return false;\n          }\n          if (!compare(returnedData, current[t])) {\n            return false;\n          }\n        }\n      } else {\n        if (current[t] !== prev[t]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n  const getSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    const shouldStartRequest = (() => {\n      if (!key) return false;\n      if (!fetcher) return false;\n      // If `revalidateOnMount` is set, we take the value directly.\n      if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(revalidateOnMount)) return revalidateOnMount;\n      // If it's paused, we skip revalidation.\n      if (getConfig().isPaused()) return false;\n      if (suspense) return false;\n      if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(revalidateIfStale)) return revalidateIfStale;\n      return true;\n    })();\n    // Get the cache and merge it with expected states.\n    const getSelectedCache = state => {\n      // We only select the needed fields from the state.\n      const snapshot = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.mergeObjects)(state);\n      delete snapshot._k;\n      if (!shouldStartRequest) {\n        return snapshot;\n      }\n      return {\n        isValidating: true,\n        isLoading: true,\n        ...snapshot\n      };\n    };\n    const cachedData = getCache();\n    const initialData = getInitialCache();\n    const clientSnapshot = getSelectedCache(cachedData);\n    const serverSnapshot = cachedData === initialData ? clientSnapshot : getSelectedCache(initialData);\n    // To make sure that we are returning the same object reference to avoid\n    // unnecessary re-renders, we keep the previous snapshot and use deep\n    // comparison to check if we need to return a new one.\n    let memorizedSnapshot = clientSnapshot;\n    return [() => {\n      const newSnapshot = getSelectedCache(getCache());\n      const compareResult = isEqual(newSnapshot, memorizedSnapshot);\n      if (compareResult) {\n        // Mentally, we should always return the `memorizedSnapshot` here\n        // as there's no change between the new and old snapshots.\n        // However, since the `isEqual` function only compares selected fields,\n        // the values of the unselected fields might be changed. That's\n        // simply because we didn't track them.\n        // To support the case in https://github.com/vercel/swr/pull/2576,\n        // we need to update these fields in the `memorizedSnapshot` too\n        // with direct mutations to ensure the snapshot is always up-to-date\n        // even for the unselected fields, but only trigger re-renders when\n        // the selected fields are changed.\n        memorizedSnapshot.data = newSnapshot.data;\n        memorizedSnapshot.isLoading = newSnapshot.isLoading;\n        memorizedSnapshot.isValidating = newSnapshot.isValidating;\n        memorizedSnapshot.error = newSnapshot.error;\n        return memorizedSnapshot;\n      } else {\n        memorizedSnapshot = newSnapshot;\n        return newSnapshot;\n      }\n    }, () => serverSnapshot];\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [cache, key]);\n  // Get the current state that SWR should return.\n  const cached = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(callback => subscribeCache(key, (current, prev) => {\n    if (!isEqual(prev, current)) callback();\n  }),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [cache, key]), getSnapshot[0], getSnapshot[1]);\n  const isInitialMount = !initialMountedRef.current;\n  const hasRevalidator = EVENT_REVALIDATORS[key] && EVENT_REVALIDATORS[key].length > 0;\n  const cachedData = cached.data;\n  const data = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cachedData) ? fallback : cachedData;\n  const error = cached.error;\n  // Use a ref to store previously returned data. Use the initial data as its initial value.\n  const laggyDataRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(data);\n  const returnedData = keepPreviousData ? (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cachedData) ? laggyDataRef.current : cachedData : data;\n  // - Suspense mode and there's stale data for the initial render.\n  // - Not suspense mode and there is no fallback data and `revalidateIfStale` is enabled.\n  // - `revalidateIfStale` is enabled but `data` is not defined.\n  const shouldDoInitialRevalidation = (() => {\n    // if a key already has revalidators and also has error, we should not trigger revalidation\n    if (hasRevalidator && !(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(error)) return false;\n    // If `revalidateOnMount` is set, we take the value directly.\n    if (isInitialMount && !(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(revalidateOnMount)) return revalidateOnMount;\n    // If it's paused, we skip revalidation.\n    if (getConfig().isPaused()) return false;\n    // Under suspense mode, it will always fetch on render if there is no\n    // stale data so no need to revalidate immediately mount it again.\n    // If data exists, only revalidate if `revalidateIfStale` is true.\n    if (suspense) return (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(data) ? false : revalidateIfStale;\n    // If there is no stale data, we need to revalidate when mount;\n    // If `revalidateIfStale` is set to true, we will always revalidate.\n    return (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(data) || revalidateIfStale;\n  })();\n  // Resolve the default validating state:\n  // If it's able to validate, and it should revalidate when mount, this will be true.\n  const defaultValidatingState = !!(key && fetcher && isInitialMount && shouldDoInitialRevalidation);\n  const isValidating = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cached.isValidating) ? defaultValidatingState : cached.isValidating;\n  const isLoading = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cached.isLoading) ? defaultValidatingState : cached.isLoading;\n  // The revalidation function is a carefully crafted wrapper of the original\n  // `fetcher`, to correctly handle the many edge cases.\n  const revalidate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async revalidateOpts => {\n    const currentFetcher = fetcherRef.current;\n    if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {\n      return false;\n    }\n    let newData;\n    let startAt;\n    let loading = true;\n    const opts = revalidateOpts || {};\n    // If there is no ongoing concurrent request, or `dedupe` is not set, a\n    // new request should be initiated.\n    const shouldStartNewRequest = !FETCH[key] || !opts.dedupe;\n    /*\n     For React 17\n     Do unmount check for calls:\n     If key has changed during the revalidation, or the component has been\n     unmounted, old dispatch and old event callbacks should not take any\n     effect\n     For React 18\n    only check if key has changed\n    https://github.com/reactwg/react-18/discussions/82\n    */\n    const callbackSafeguard = () => {\n      if (swr_internal__WEBPACK_IMPORTED_MODULE_3__.IS_REACT_LEGACY) {\n        return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;\n      }\n      return key === keyRef.current;\n    };\n    // The final state object when the request finishes.\n    const finalState = {\n      isValidating: false,\n      isLoading: false\n    };\n    const finishRequestAndUpdateState = () => {\n      setCache(finalState);\n    };\n    const cleanupState = () => {\n      // Check if it's still the same request before deleting it.\n      const requestInfo = FETCH[key];\n      if (requestInfo && requestInfo[1] === startAt) {\n        delete FETCH[key];\n      }\n    };\n    // Start fetching. Change the `isValidating` state, update the cache.\n    const initialState = {\n      isValidating: true\n    };\n    // It is in the `isLoading` state, if and only if there is no cached data.\n    // This bypasses fallback data and laggy data.\n    if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(getCache().data)) {\n      initialState.isLoading = true;\n    }\n    try {\n      if (shouldStartNewRequest) {\n        setCache(initialState);\n        // If no cache is being rendered currently (it shows a blank page),\n        // we trigger the loading slow event.\n        if (config.loadingTimeout && (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(getCache().data)) {\n          setTimeout(() => {\n            if (loading && callbackSafeguard()) {\n              getConfig().onLoadingSlow(key, config);\n            }\n          }, config.loadingTimeout);\n        }\n        // Start the request and save the timestamp.\n        // Key must be truthy if entering here.\n        FETCH[key] = [currentFetcher(fnArg), (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.getTimestamp)()];\n      }\n      [newData, startAt] = FETCH[key];\n      newData = await newData;\n      if (shouldStartNewRequest) {\n        // If the request isn't interrupted, clean it up after the\n        // deduplication interval.\n        setTimeout(cleanupState, config.dedupingInterval);\n      }\n      // If there're other ongoing request(s), started after the current one,\n      // we need to ignore the current one to avoid possible race conditions:\n      //   req1------------------>res1        (current one)\n      //        req2---------------->res2\n      // the request that fired later will always be kept.\n      // The timestamp maybe be `undefined` or a number\n      if (!FETCH[key] || FETCH[key][1] !== startAt) {\n        if (shouldStartNewRequest) {\n          if (callbackSafeguard()) {\n            getConfig().onDiscarded(key);\n          }\n        }\n        return false;\n      }\n      // Clear error.\n      finalState.error = swr_internal__WEBPACK_IMPORTED_MODULE_3__.UNDEFINED;\n      // If there're other mutations(s), that overlapped with the current revalidation:\n      // case 1:\n      //   req------------------>res\n      //       mutate------>end\n      // case 2:\n      //         req------------>res\n      //   mutate------>end\n      // case 3:\n      //   req------------------>res\n      //       mutate-------...---------->\n      // we have to ignore the revalidation result (res) because it's no longer fresh.\n      // meanwhile, a new revalidation should be triggered when the mutation ends.\n      const mutationInfo = MUTATION[key];\n      if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(mutationInfo) && (\n      // case 1\n      startAt <= mutationInfo[0] ||\n      // case 2\n      startAt <= mutationInfo[1] ||\n      // case 3\n      mutationInfo[1] === 0)) {\n        finishRequestAndUpdateState();\n        if (shouldStartNewRequest) {\n          if (callbackSafeguard()) {\n            getConfig().onDiscarded(key);\n          }\n        }\n        return false;\n      }\n      // Deep compare with the latest state to avoid extra re-renders.\n      // For local state, compare and assign.\n      const cacheData = getCache().data;\n      // Since the compare fn could be custom fn\n      // cacheData might be different from newData even when compare fn returns True\n      finalState.data = compare(cacheData, newData) ? cacheData : newData;\n      // Trigger the successful callback if it's the original request.\n      if (shouldStartNewRequest) {\n        if (callbackSafeguard()) {\n          getConfig().onSuccess(newData, key, config);\n        }\n      }\n    } catch (err) {\n      cleanupState();\n      const currentConfig = getConfig();\n      const {\n        shouldRetryOnError\n      } = currentConfig;\n      // Not paused, we continue handling the error. Otherwise, discard it.\n      if (!currentConfig.isPaused()) {\n        // Get a new error, don't use deep comparison for errors.\n        finalState.error = err;\n        // Error event and retry logic. Only for the actual request, not\n        // deduped ones.\n        if (shouldStartNewRequest && callbackSafeguard()) {\n          currentConfig.onError(err, key, currentConfig);\n          if (shouldRetryOnError === true || (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isFunction)(shouldRetryOnError) && shouldRetryOnError(err)) {\n            if (!getConfig().revalidateOnFocus || !getConfig().revalidateOnReconnect || isActive()) {\n              // If it's inactive, stop. It will auto-revalidate when\n              // refocusing or reconnecting.\n              // When retrying, deduplication is always enabled.\n              currentConfig.onErrorRetry(err, key, currentConfig, _opts => {\n                const revalidators = EVENT_REVALIDATORS[key];\n                if (revalidators && revalidators[0]) {\n                  revalidators[0](swr_internal__WEBPACK_IMPORTED_MODULE_3__.revalidateEvents.ERROR_REVALIDATE_EVENT, _opts);\n                }\n              }, {\n                retryCount: (opts.retryCount || 0) + 1,\n                dedupe: true\n              });\n            }\n          }\n        }\n      }\n    }\n    // Mark loading as stopped.\n    loading = false;\n    // Update the current hook's state.\n    finishRequestAndUpdateState();\n    return true;\n  },\n  // `setState` is immutable, and `eventsCallback`, `fnArg`, and\n  // `keyValidating` are depending on `key`, so we can exclude them from\n  // the deps array.\n  //\n  // FIXME:\n  // `fn` and `config` might be changed during the lifecycle,\n  // but they might be changed every render like this.\n  // `useSWR('key', () => fetch('/api/'), { suspense: true })`\n  // So we omit the values from the deps array\n  // even though it might cause unexpected behaviors.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [key, cache]);\n  // Similar to the global mutate but bound to the current cache and key.\n  // `cache` isn't allowed to change during the lifecycle.\n  const boundMutate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n  // Use callback to make sure `keyRef.current` returns latest result every time\n  (...args) => {\n    return (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.internalMutate)(cache, keyRef.current, ...args);\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  // The logic for updating refs.\n  (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.useIsomorphicLayoutEffect)(() => {\n    fetcherRef.current = fetcher;\n    configRef.current = config;\n    // Handle laggy data updates. If there's cached data of the current key,\n    // it'll be the correct reference.\n    if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cachedData)) {\n      laggyDataRef.current = cachedData;\n    }\n  });\n  // After mounted or key changed.\n  (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.useIsomorphicLayoutEffect)(() => {\n    if (!key) return;\n    const softRevalidate = revalidate.bind(swr_internal__WEBPACK_IMPORTED_MODULE_3__.UNDEFINED, WITH_DEDUPE);\n    // Expose revalidators to global event listeners. So we can trigger\n    // revalidation from the outside.\n    let nextFocusRevalidatedAt = 0;\n    const onRevalidate = (type, opts = {}) => {\n      if (type == swr_internal__WEBPACK_IMPORTED_MODULE_3__.revalidateEvents.FOCUS_EVENT) {\n        const now = Date.now();\n        if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {\n          nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;\n          softRevalidate();\n        }\n      } else if (type == swr_internal__WEBPACK_IMPORTED_MODULE_3__.revalidateEvents.RECONNECT_EVENT) {\n        if (getConfig().revalidateOnReconnect && isActive()) {\n          softRevalidate();\n        }\n      } else if (type == swr_internal__WEBPACK_IMPORTED_MODULE_3__.revalidateEvents.MUTATE_EVENT) {\n        return revalidate();\n      } else if (type == swr_internal__WEBPACK_IMPORTED_MODULE_3__.revalidateEvents.ERROR_REVALIDATE_EVENT) {\n        return revalidate(opts);\n      }\n      return;\n    };\n    const unsubEvents = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.subscribeCallback)(key, EVENT_REVALIDATORS, onRevalidate);\n    // Mark the component as mounted and update corresponding refs.\n    unmountedRef.current = false;\n    keyRef.current = key;\n    initialMountedRef.current = true;\n    // Keep the original key in the cache.\n    setCache({\n      _k: fnArg\n    });\n    // Trigger a revalidation\n    if (shouldDoInitialRevalidation) {\n      if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(data) || swr_internal__WEBPACK_IMPORTED_MODULE_3__.IS_SERVER) {\n        // Revalidate immediately.\n        softRevalidate();\n      } else {\n        // Delay the revalidate if we have data to return so we won't block\n        // rendering.\n        (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.rAF)(softRevalidate);\n      }\n    }\n    return () => {\n      // Mark it as unmounted.\n      unmountedRef.current = true;\n      unsubEvents();\n    };\n  }, [key]);\n  // Polling\n  (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.useIsomorphicLayoutEffect)(() => {\n    let timer;\n    function next() {\n      // Use the passed interval\n      // ...or invoke the function with the updated data to get the interval\n      const interval = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isFunction)(refreshInterval) ? refreshInterval(getCache().data) : refreshInterval;\n      // We only start the next interval if `refreshInterval` is not 0, and:\n      // - `force` is true, which is the start of polling\n      // - or `timer` is not 0, which means the effect wasn't canceled\n      if (interval && timer !== -1) {\n        timer = setTimeout(execute, interval);\n      }\n    }\n    function execute() {\n      // Check if it's OK to execute:\n      // Only revalidate when the page is visible, online, and not errored.\n      if (!getCache().error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {\n        revalidate(WITH_DEDUPE).then(next);\n      } else {\n        // Schedule the next interval to check again.\n        next();\n      }\n    }\n    next();\n    return () => {\n      if (timer) {\n        clearTimeout(timer);\n        timer = -1;\n      }\n    };\n  }, [refreshInterval, refreshWhenHidden, refreshWhenOffline, key]);\n  // Display debug info in React DevTools.\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useDebugValue)(returnedData);\n  // In Suspense mode, we can't return the empty `data` state.\n  // If there is an `error`, the `error` needs to be thrown to the error boundary.\n  // If there is no `error`, the `revalidation` promise needs to be thrown to\n  // the suspense boundary.\n  if (suspense && (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(data) && key) {\n    // SWR should throw when trying to use Suspense on the server with React 18,\n    // without providing any initial data. See:\n    // https://github.com/vercel/swr/issues/1832\n    if (!swr_internal__WEBPACK_IMPORTED_MODULE_3__.IS_REACT_LEGACY && swr_internal__WEBPACK_IMPORTED_MODULE_3__.IS_SERVER) {\n      throw new Error('Fallback data is required when using suspense in SSR.');\n    }\n    // Always update fetcher and config refs even with the Suspense mode.\n    fetcherRef.current = fetcher;\n    configRef.current = config;\n    unmountedRef.current = false;\n    const req = PRELOAD[key];\n    if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(req)) {\n      const promise = boundMutate(req);\n      use(promise);\n    }\n    if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(error)) {\n      const promise = revalidate(WITH_DEDUPE);\n      if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(returnedData)) {\n        promise.status = 'fulfilled';\n        promise.value = true;\n      }\n      use(promise);\n    } else {\n      throw error;\n    }\n  }\n  return {\n    mutate: boundMutate,\n    get data() {\n      stateDependencies.data = true;\n      return returnedData;\n    },\n    get error() {\n      stateDependencies.error = true;\n      return error;\n    },\n    get isValidating() {\n      stateDependencies.isValidating = true;\n      return isValidating;\n    },\n    get isLoading() {\n      stateDependencies.isLoading = true;\n      return isLoading;\n    }\n  };\n};\nconst SWRConfig = swr_internal__WEBPACK_IMPORTED_MODULE_3__.OBJECT.defineProperty(swr_internal__WEBPACK_IMPORTED_MODULE_3__.SWRConfig, 'defaultValue', {\n  value: swr_internal__WEBPACK_IMPORTED_MODULE_3__.defaultConfig\n});\n/**\n * A hook to fetch data.\n *\n * @link https://swr.vercel.app\n * @example\n * ```jsx\n * import useSWR from 'swr'\n * function Profile() {\n *   const { data, error, isLoading } = useSWR('/api/user', fetcher)\n *   if (error) return <div>failed to load</div>\n *   if (isLoading) return <div>loading...</div>\n *   return <div>hello {data.name}!</div>\n * }\n * ```\n */\nconst useSWR = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.withArgs)(useSWRHandler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dyL2Rpc3QvY29yZS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFxQjtBQUM2RDtBQUNMO0FBQzRPO0FBQzNQO0FBRTlELE1BQU02QixrQkFBa0IsR0FBSUMsR0FBRyxJQUFHeEIsdURBQVMsQ0FBQ3dCLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7QUFFbkQ7QUFDQSxNQUFNQyxHQUFHLEdBQUcvQixzQ0FBZ0IsS0FBTWdDLE9BQU8sSUFBRztFQUN4QyxJQUFJQSxPQUFPLENBQUNDLE1BQU0sS0FBSyxTQUFTLEVBQUU7SUFDOUIsTUFBTUQsT0FBTztFQUNqQixDQUFDLE1BQU0sSUFBSUEsT0FBTyxDQUFDQyxNQUFNLEtBQUssV0FBVyxFQUFFO0lBQ3ZDLE9BQU9ELE9BQU8sQ0FBQ0UsS0FBSztFQUN4QixDQUFDLE1BQU0sSUFBSUYsT0FBTyxDQUFDQyxNQUFNLEtBQUssVUFBVSxFQUFFO0lBQ3RDLE1BQU1ELE9BQU8sQ0FBQ0csTUFBTTtFQUN4QixDQUFDLE1BQU07SUFDSEgsT0FBTyxDQUFDQyxNQUFNLEdBQUcsU0FBUztJQUMxQkQsT0FBTyxDQUFDSSxJQUFJLENBQUVDLENBQUMsSUFBRztNQUNkTCxPQUFPLENBQUNDLE1BQU0sR0FBRyxXQUFXO01BQzVCRCxPQUFPLENBQUNFLEtBQUssR0FBR0csQ0FBQztJQUNyQixDQUFDLEVBQUdDLENBQUMsSUFBRztNQUNKTixPQUFPLENBQUNDLE1BQU0sR0FBRyxVQUFVO01BQzNCRCxPQUFPLENBQUNHLE1BQU0sR0FBR0csQ0FBQztJQUN0QixDQUFDLENBQUM7SUFDRixNQUFNTixPQUFPO0VBQ2pCO0FBQ0osQ0FBQyxDQUFDO0FBQ0YsTUFBTU8sV0FBVyxHQUFHO0VBQ2hCQyxNQUFNLEVBQUU7QUFDWixDQUFDO0FBQ0QsTUFBTUMsYUFBYSxHQUFHQSxDQUFDQyxJQUFJLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxLQUFHO0VBQzNDLE1BQU07SUFBRUMsS0FB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O0FBQUksTUFBTXlKLE1BQU0sR0FBR3hKLHNEQUFRLENBQUM4QixhQUFhLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcmMvLi9ub2RlX21vZHVsZXMvc3dyL2Rpc3QvY29yZS9pbmRleC5tanM/ZTk0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ2NsaWVudC1vbmx5JztcbmltcG9ydCBSZWFjdEV4cG9ydHMsIHsgdXNlUmVmLCB1c2VNZW1vLCB1c2VDYWxsYmFjaywgdXNlRGVidWdWYWx1ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIH0gZnJvbSAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qcyc7XG5pbXBvcnQgeyBzZXJpYWxpemUsIE9CSkVDVCwgU1dSQ29uZmlnIGFzIFNXUkNvbmZpZyQxLCBkZWZhdWx0Q29uZmlnLCB3aXRoQXJncywgU1dSR2xvYmFsU3RhdGUsIGNyZWF0ZUNhY2hlSGVscGVyLCBpc1VuZGVmaW5lZCwgZ2V0VGltZXN0YW1wLCBVTkRFRklORUQsIGlzRnVuY3Rpb24sIHJldmFsaWRhdGVFdmVudHMsIGludGVybmFsTXV0YXRlLCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LCBzdWJzY3JpYmVDYWxsYmFjaywgSVNfU0VSVkVSLCByQUYsIElTX1JFQUNUX0xFR0FDWSwgbWVyZ2VPYmplY3RzIH0gZnJvbSAnc3dyL19pbnRlcm5hbCc7XG5leHBvcnQgeyBtdXRhdGUsIHByZWxvYWQsIHVzZVNXUkNvbmZpZyB9IGZyb20gJ3N3ci9faW50ZXJuYWwnO1xuXG5jb25zdCB1bnN0YWJsZV9zZXJpYWxpemUgPSAoa2V5KT0+c2VyaWFsaXplKGtleSlbMF07XG5cbi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwicmVhY3QvZXhwZXJpbWVudGFsXCIgLz5cbmNvbnN0IHVzZSA9IFJlYWN0RXhwb3J0cy51c2UgfHwgKChwcm9taXNlKT0+e1xuICAgIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgIHRocm93IHByb21pc2U7XG4gICAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudmFsdWU7XG4gICAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gJ3JlamVjdGVkJykge1xuICAgICAgICB0aHJvdyBwcm9taXNlLnJlYXNvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlLnN0YXR1cyA9ICdwZW5kaW5nJztcbiAgICAgICAgcHJvbWlzZS50aGVuKCh2KT0+e1xuICAgICAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgICAgICAgICAgIHByb21pc2UudmFsdWUgPSB2O1xuICAgICAgICB9LCAoZSk9PntcbiAgICAgICAgICAgIHByb21pc2Uuc3RhdHVzID0gJ3JlamVjdGVkJztcbiAgICAgICAgICAgIHByb21pc2UucmVhc29uID0gZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IHByb21pc2U7XG4gICAgfVxufSk7XG5jb25zdCBXSVRIX0RFRFVQRSA9IHtcbiAgICBkZWR1cGU6IHRydWVcbn07XG5jb25zdCB1c2VTV1JIYW5kbGVyID0gKF9rZXksIGZldGNoZXIsIGNvbmZpZyk9PntcbiAgICBjb25zdCB7IGNhY2hlLCBjb21wYXJlLCBzdXNwZW5zZSwgZmFsbGJhY2tEYXRhLCByZXZhbGlkYXRlT25Nb3VudCwgcmV2YWxpZGF0ZUlmU3RhbGUsIHJlZnJlc2hJbnRlcnZhbCwgcmVmcmVzaFdoZW5IaWRkZW4sIHJlZnJlc2hXaGVuT2ZmbGluZSwga2VlcFByZXZpb3VzRGF0YSB9ID0gY29uZmlnO1xuICAgIGNvbnN0IFtFVkVOVF9SRVZBTElEQVRPUlMsIE1VVEFUSU9OLCBGRVRDSCwgUFJFTE9BRF0gPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpO1xuICAgIC8vIGBrZXlgIGlzIHRoZSBpZGVudGlmaWVyIG9mIHRoZSBTV1IgaW50ZXJuYWwgc3RhdGUsXG4gICAgLy8gYGZuQXJnYCBpcyB0aGUgYXJndW1lbnQvYXJndW1lbnRzIHBhcnNlZCBmcm9tIHRoZSBrZXksIHdoaWNoIHdpbGwgYmUgcGFzc2VkXG4gICAgLy8gdG8gdGhlIGZldGNoZXIuXG4gICAgLy8gQWxsIG9mIHRoZW0gYXJlIGRlcml2ZWQgZnJvbSBgX2tleWAuXG4gICAgY29uc3QgW2tleSwgZm5BcmddID0gc2VyaWFsaXplKF9rZXkpO1xuICAgIC8vIElmIGl0J3MgdGhlIGluaXRpYWwgcmVuZGVyIG9mIHRoaXMgaG9vay5cbiAgICBjb25zdCBpbml0aWFsTW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gSWYgdGhlIGhvb2sgaXMgdW5tb3VudGVkIGFscmVhZHkuIFRoaXMgd2lsbCBiZSB1c2VkIHRvIHByZXZlbnQgc29tZSBlZmZlY3RzXG4gICAgLy8gdG8gYmUgY2FsbGVkIGFmdGVyIHVubW91bnRpbmcuXG4gICAgY29uc3QgdW5tb3VudGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICAvLyBSZWZzIHRvIGtlZXAgdGhlIGtleSBhbmQgY29uZmlnLlxuICAgIGNvbnN0IGtleVJlZiA9IHVzZVJlZihrZXkpO1xuICAgIGNvbnN0IGZldGNoZXJSZWYgPSB1c2VSZWYoZmV0Y2hlcik7XG4gICAgY29uc3QgY29uZmlnUmVmID0gdXNlUmVmKGNvbmZpZyk7XG4gICAgY29uc3QgZ2V0Q29uZmlnID0gKCk9PmNvbmZpZ1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGlzQWN0aXZlID0gKCk9PmdldENvbmZpZygpLmlzVmlzaWJsZSgpICYmIGdldENvbmZpZygpLmlzT25saW5lKCk7XG4gICAgY29uc3QgW2dldENhY2hlLCBzZXRDYWNoZSwgc3Vic2NyaWJlQ2FjaGUsIGdldEluaXRpYWxDYWNoZV0gPSBjcmVhdGVDYWNoZUhlbHBlcihjYWNoZSwga2V5KTtcbiAgICBjb25zdCBzdGF0ZURlcGVuZGVuY2llcyA9IHVzZVJlZih7fSkuY3VycmVudDtcbiAgICBjb25zdCBmYWxsYmFjayA9IGlzVW5kZWZpbmVkKGZhbGxiYWNrRGF0YSkgPyBjb25maWcuZmFsbGJhY2tba2V5XSA6IGZhbGxiYWNrRGF0YTtcbiAgICBjb25zdCBpc0VxdWFsID0gKHByZXYsIGN1cnJlbnQpPT57XG4gICAgICAgIGZvcihjb25zdCBfIGluIHN0YXRlRGVwZW5kZW5jaWVzKXtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBfO1xuICAgICAgICAgICAgaWYgKHQgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgICAgIGlmICghY29tcGFyZShwcmV2W3RdLCBjdXJyZW50W3RdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHByZXZbdF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlKHJldHVybmVkRGF0YSwgY3VycmVudFt0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRbdF0gIT09IHByZXZbdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFNuYXBzaG90ID0gdXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCBzaG91bGRTdGFydFJlcXVlc3QgPSAoKCk9PntcbiAgICAgICAgICAgIGlmICgha2V5KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWZldGNoZXIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIC8vIElmIGByZXZhbGlkYXRlT25Nb3VudGAgaXMgc2V0LCB3ZSB0YWtlIHRoZSB2YWx1ZSBkaXJlY3RseS5cbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQocmV2YWxpZGF0ZU9uTW91bnQpKSByZXR1cm4gcmV2YWxpZGF0ZU9uTW91bnQ7XG4gICAgICAgICAgICAvLyBJZiBpdCdzIHBhdXNlZCwgd2Ugc2tpcCByZXZhbGlkYXRpb24uXG4gICAgICAgICAgICBpZiAoZ2V0Q29uZmlnKCkuaXNQYXVzZWQoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN1c3BlbnNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHJldmFsaWRhdGVJZlN0YWxlKSkgcmV0dXJuIHJldmFsaWRhdGVJZlN0YWxlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIC8vIEdldCB0aGUgY2FjaGUgYW5kIG1lcmdlIGl0IHdpdGggZXhwZWN0ZWQgc3RhdGVzLlxuICAgICAgICBjb25zdCBnZXRTZWxlY3RlZENhY2hlID0gKHN0YXRlKT0+e1xuICAgICAgICAgICAgLy8gV2Ugb25seSBzZWxlY3QgdGhlIG5lZWRlZCBmaWVsZHMgZnJvbSB0aGUgc3RhdGUuXG4gICAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IG1lcmdlT2JqZWN0cyhzdGF0ZSk7XG4gICAgICAgICAgICBkZWxldGUgc25hcHNob3QuX2s7XG4gICAgICAgICAgICBpZiAoIXNob3VsZFN0YXJ0UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzbmFwc2hvdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAuLi5zbmFwc2hvdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2FjaGVkRGF0YSA9IGdldENhY2hlKCk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxEYXRhID0gZ2V0SW5pdGlhbENhY2hlKCk7XG4gICAgICAgIGNvbnN0IGNsaWVudFNuYXBzaG90ID0gZ2V0U2VsZWN0ZWRDYWNoZShjYWNoZWREYXRhKTtcbiAgICAgICAgY29uc3Qgc2VydmVyU25hcHNob3QgPSBjYWNoZWREYXRhID09PSBpbml0aWFsRGF0YSA/IGNsaWVudFNuYXBzaG90IDogZ2V0U2VsZWN0ZWRDYWNoZShpbml0aWFsRGF0YSk7XG4gICAgICAgIC8vIFRvIG1ha2Ugc3VyZSB0aGF0IHdlIGFyZSByZXR1cm5pbmcgdGhlIHNhbWUgb2JqZWN0IHJlZmVyZW5jZSB0byBhdm9pZFxuICAgICAgICAvLyB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzLCB3ZSBrZWVwIHRoZSBwcmV2aW91cyBzbmFwc2hvdCBhbmQgdXNlIGRlZXBcbiAgICAgICAgLy8gY29tcGFyaXNvbiB0byBjaGVjayBpZiB3ZSBuZWVkIHRvIHJldHVybiBhIG5ldyBvbmUuXG4gICAgICAgIGxldCBtZW1vcml6ZWRTbmFwc2hvdCA9IGNsaWVudFNuYXBzaG90O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTbmFwc2hvdCA9IGdldFNlbGVjdGVkQ2FjaGUoZ2V0Q2FjaGUoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGFyZVJlc3VsdCA9IGlzRXF1YWwobmV3U25hcHNob3QsIG1lbW9yaXplZFNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNZW50YWxseSwgd2Ugc2hvdWxkIGFsd2F5cyByZXR1cm4gdGhlIGBtZW1vcml6ZWRTbmFwc2hvdGAgaGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBhcyB0aGVyZSdzIG5vIGNoYW5nZSBiZXR3ZWVuIHRoZSBuZXcgYW5kIG9sZCBzbmFwc2hvdHMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHNpbmNlIHRoZSBgaXNFcXVhbGAgZnVuY3Rpb24gb25seSBjb21wYXJlcyBzZWxlY3RlZCBmaWVsZHMsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB2YWx1ZXMgb2YgdGhlIHVuc2VsZWN0ZWQgZmllbGRzIG1pZ2h0IGJlIGNoYW5nZWQuIFRoYXQnc1xuICAgICAgICAgICAgICAgICAgICAvLyBzaW1wbHkgYmVjYXVzZSB3ZSBkaWRuJ3QgdHJhY2sgdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVG8gc3VwcG9ydCB0aGUgY2FzZSBpbiBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL3N3ci9wdWxsLzI1NzYsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gdXBkYXRlIHRoZXNlIGZpZWxkcyBpbiB0aGUgYG1lbW9yaXplZFNuYXBzaG90YCB0b29cbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCBkaXJlY3QgbXV0YXRpb25zIHRvIGVuc3VyZSB0aGUgc25hcHNob3QgaXMgYWx3YXlzIHVwLXRvLWRhdGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbiBmb3IgdGhlIHVuc2VsZWN0ZWQgZmllbGRzLCBidXQgb25seSB0cmlnZ2VyIHJlLXJlbmRlcnMgd2hlblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2VsZWN0ZWQgZmllbGRzIGFyZSBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICAgICBtZW1vcml6ZWRTbmFwc2hvdC5kYXRhID0gbmV3U25hcHNob3QuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgbWVtb3JpemVkU25hcHNob3QuaXNMb2FkaW5nID0gbmV3U25hcHNob3QuaXNMb2FkaW5nO1xuICAgICAgICAgICAgICAgICAgICBtZW1vcml6ZWRTbmFwc2hvdC5pc1ZhbGlkYXRpbmcgPSBuZXdTbmFwc2hvdC5pc1ZhbGlkYXRpbmc7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9yaXplZFNuYXBzaG90LmVycm9yID0gbmV3U25hcHNob3QuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vcml6ZWRTbmFwc2hvdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZW1vcml6ZWRTbmFwc2hvdCA9IG5ld1NuYXBzaG90O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3U25hcHNob3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpPT5zZXJ2ZXJTbmFwc2hvdFxuICAgICAgICBdO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBrZXlcbiAgICBdKTtcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgc3RhdGUgdGhhdCBTV1Igc2hvdWxkIHJldHVybi5cbiAgICBjb25zdCBjYWNoZWQgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZSh1c2VDYWxsYmFjaygoY2FsbGJhY2spPT5zdWJzY3JpYmVDYWNoZShrZXksIChjdXJyZW50LCBwcmV2KT0+e1xuICAgICAgICAgICAgaWYgKCFpc0VxdWFsKHByZXYsIGN1cnJlbnQpKSBjYWxsYmFjaygpO1xuICAgICAgICB9KSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGtleVxuICAgIF0pLCBnZXRTbmFwc2hvdFswXSwgZ2V0U25hcHNob3RbMV0pO1xuICAgIGNvbnN0IGlzSW5pdGlhbE1vdW50ID0gIWluaXRpYWxNb3VudGVkUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgaGFzUmV2YWxpZGF0b3IgPSBFVkVOVF9SRVZBTElEQVRPUlNba2V5XSAmJiBFVkVOVF9SRVZBTElEQVRPUlNba2V5XS5sZW5ndGggPiAwO1xuICAgIGNvbnN0IGNhY2hlZERhdGEgPSBjYWNoZWQuZGF0YTtcbiAgICBjb25zdCBkYXRhID0gaXNVbmRlZmluZWQoY2FjaGVkRGF0YSkgPyBmYWxsYmFjayA6IGNhY2hlZERhdGE7XG4gICAgY29uc3QgZXJyb3IgPSBjYWNoZWQuZXJyb3I7XG4gICAgLy8gVXNlIGEgcmVmIHRvIHN0b3JlIHByZXZpb3VzbHkgcmV0dXJuZWQgZGF0YS4gVXNlIHRoZSBpbml0aWFsIGRhdGEgYXMgaXRzIGluaXRpYWwgdmFsdWUuXG4gICAgY29uc3QgbGFnZ3lEYXRhUmVmID0gdXNlUmVmKGRhdGEpO1xuICAgIGNvbnN0IHJldHVybmVkRGF0YSA9IGtlZXBQcmV2aW91c0RhdGEgPyBpc1VuZGVmaW5lZChjYWNoZWREYXRhKSA/IGxhZ2d5RGF0YVJlZi5jdXJyZW50IDogY2FjaGVkRGF0YSA6IGRhdGE7XG4gICAgLy8gLSBTdXNwZW5zZSBtb2RlIGFuZCB0aGVyZSdzIHN0YWxlIGRhdGEgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICAvLyAtIE5vdCBzdXNwZW5zZSBtb2RlIGFuZCB0aGVyZSBpcyBubyBmYWxsYmFjayBkYXRhIGFuZCBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIGVuYWJsZWQuXG4gICAgLy8gLSBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIGVuYWJsZWQgYnV0IGBkYXRhYCBpcyBub3QgZGVmaW5lZC5cbiAgICBjb25zdCBzaG91bGREb0luaXRpYWxSZXZhbGlkYXRpb24gPSAoKCk9PntcbiAgICAgICAgLy8gaWYgYSBrZXkgYWxyZWFkeSBoYXMgcmV2YWxpZGF0b3JzIGFuZCBhbHNvIGhhcyBlcnJvciwgd2Ugc2hvdWxkIG5vdCB0cmlnZ2VyIHJldmFsaWRhdGlvblxuICAgICAgICBpZiAoaGFzUmV2YWxpZGF0b3IgJiYgIWlzVW5kZWZpbmVkKGVycm9yKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBJZiBgcmV2YWxpZGF0ZU9uTW91bnRgIGlzIHNldCwgd2UgdGFrZSB0aGUgdmFsdWUgZGlyZWN0bHkuXG4gICAgICAgIGlmIChpc0luaXRpYWxNb3VudCAmJiAhaXNVbmRlZmluZWQocmV2YWxpZGF0ZU9uTW91bnQpKSByZXR1cm4gcmV2YWxpZGF0ZU9uTW91bnQ7XG4gICAgICAgIC8vIElmIGl0J3MgcGF1c2VkLCB3ZSBza2lwIHJldmFsaWRhdGlvbi5cbiAgICAgICAgaWYgKGdldENvbmZpZygpLmlzUGF1c2VkKCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gVW5kZXIgc3VzcGVuc2UgbW9kZSwgaXQgd2lsbCBhbHdheXMgZmV0Y2ggb24gcmVuZGVyIGlmIHRoZXJlIGlzIG5vXG4gICAgICAgIC8vIHN0YWxlIGRhdGEgc28gbm8gbmVlZCB0byByZXZhbGlkYXRlIGltbWVkaWF0ZWx5IG1vdW50IGl0IGFnYWluLlxuICAgICAgICAvLyBJZiBkYXRhIGV4aXN0cywgb25seSByZXZhbGlkYXRlIGlmIGByZXZhbGlkYXRlSWZTdGFsZWAgaXMgdHJ1ZS5cbiAgICAgICAgaWYgKHN1c3BlbnNlKSByZXR1cm4gaXNVbmRlZmluZWQoZGF0YSkgPyBmYWxzZSA6IHJldmFsaWRhdGVJZlN0YWxlO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBzdGFsZSBkYXRhLCB3ZSBuZWVkIHRvIHJldmFsaWRhdGUgd2hlbiBtb3VudDtcbiAgICAgICAgLy8gSWYgYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBzZXQgdG8gdHJ1ZSwgd2Ugd2lsbCBhbHdheXMgcmV2YWxpZGF0ZS5cbiAgICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkKGRhdGEpIHx8IHJldmFsaWRhdGVJZlN0YWxlO1xuICAgIH0pKCk7XG4gICAgLy8gUmVzb2x2ZSB0aGUgZGVmYXVsdCB2YWxpZGF0aW5nIHN0YXRlOlxuICAgIC8vIElmIGl0J3MgYWJsZSB0byB2YWxpZGF0ZSwgYW5kIGl0IHNob3VsZCByZXZhbGlkYXRlIHdoZW4gbW91bnQsIHRoaXMgd2lsbCBiZSB0cnVlLlxuICAgIGNvbnN0IGRlZmF1bHRWYWxpZGF0aW5nU3RhdGUgPSAhIShrZXkgJiYgZmV0Y2hlciAmJiBpc0luaXRpYWxNb3VudCAmJiBzaG91bGREb0luaXRpYWxSZXZhbGlkYXRpb24pO1xuICAgIGNvbnN0IGlzVmFsaWRhdGluZyA9IGlzVW5kZWZpbmVkKGNhY2hlZC5pc1ZhbGlkYXRpbmcpID8gZGVmYXVsdFZhbGlkYXRpbmdTdGF0ZSA6IGNhY2hlZC5pc1ZhbGlkYXRpbmc7XG4gICAgY29uc3QgaXNMb2FkaW5nID0gaXNVbmRlZmluZWQoY2FjaGVkLmlzTG9hZGluZykgPyBkZWZhdWx0VmFsaWRhdGluZ1N0YXRlIDogY2FjaGVkLmlzTG9hZGluZztcbiAgICAvLyBUaGUgcmV2YWxpZGF0aW9uIGZ1bmN0aW9uIGlzIGEgY2FyZWZ1bGx5IGNyYWZ0ZWQgd3JhcHBlciBvZiB0aGUgb3JpZ2luYWxcbiAgICAvLyBgZmV0Y2hlcmAsIHRvIGNvcnJlY3RseSBoYW5kbGUgdGhlIG1hbnkgZWRnZSBjYXNlcy5cbiAgICBjb25zdCByZXZhbGlkYXRlID0gdXNlQ2FsbGJhY2soYXN5bmMgKHJldmFsaWRhdGVPcHRzKT0+e1xuICAgICAgICBjb25zdCBjdXJyZW50RmV0Y2hlciA9IGZldGNoZXJSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFrZXkgfHwgIWN1cnJlbnRGZXRjaGVyIHx8IHVubW91bnRlZFJlZi5jdXJyZW50IHx8IGdldENvbmZpZygpLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3RGF0YTtcbiAgICAgICAgbGV0IHN0YXJ0QXQ7XG4gICAgICAgIGxldCBsb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHJldmFsaWRhdGVPcHRzIHx8IHt9O1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBvbmdvaW5nIGNvbmN1cnJlbnQgcmVxdWVzdCwgb3IgYGRlZHVwZWAgaXMgbm90IHNldCwgYVxuICAgICAgICAvLyBuZXcgcmVxdWVzdCBzaG91bGQgYmUgaW5pdGlhdGVkLlxuICAgICAgICBjb25zdCBzaG91bGRTdGFydE5ld1JlcXVlc3QgPSAhRkVUQ0hba2V5XSB8fCAhb3B0cy5kZWR1cGU7XG4gICAgICAgIC8qXG4gICAgICAgICBGb3IgUmVhY3QgMTdcbiAgICAgICAgIERvIHVubW91bnQgY2hlY2sgZm9yIGNhbGxzOlxuICAgICAgICAgSWYga2V5IGhhcyBjaGFuZ2VkIGR1cmluZyB0aGUgcmV2YWxpZGF0aW9uLCBvciB0aGUgY29tcG9uZW50IGhhcyBiZWVuXG4gICAgICAgICB1bm1vdW50ZWQsIG9sZCBkaXNwYXRjaCBhbmQgb2xkIGV2ZW50IGNhbGxiYWNrcyBzaG91bGQgbm90IHRha2UgYW55XG4gICAgICAgICBlZmZlY3RcblxuICAgICAgICBGb3IgUmVhY3QgMThcbiAgICAgICAgb25seSBjaGVjayBpZiBrZXkgaGFzIGNoYW5nZWRcbiAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0d2cvcmVhY3QtMTgvZGlzY3Vzc2lvbnMvODJcbiAgICAgICovIGNvbnN0IGNhbGxiYWNrU2FmZWd1YXJkID0gKCk9PntcbiAgICAgICAgICAgIGlmIChJU19SRUFDVF9MRUdBQ1kpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXVubW91bnRlZFJlZi5jdXJyZW50ICYmIGtleSA9PT0ga2V5UmVmLmN1cnJlbnQgJiYgaW5pdGlhbE1vdW50ZWRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXkgPT09IGtleVJlZi5jdXJyZW50O1xuICAgICAgICB9O1xuICAgICAgICAvLyBUaGUgZmluYWwgc3RhdGUgb2JqZWN0IHdoZW4gdGhlIHJlcXVlc3QgZmluaXNoZXMuXG4gICAgICAgIGNvbnN0IGZpbmFsU3RhdGUgPSB7XG4gICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUgPSAoKT0+e1xuICAgICAgICAgICAgc2V0Q2FjaGUoZmluYWxTdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsZWFudXBTdGF0ZSA9ICgpPT57XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIHN0aWxsIHRoZSBzYW1lIHJlcXVlc3QgYmVmb3JlIGRlbGV0aW5nIGl0LlxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEluZm8gPSBGRVRDSFtrZXldO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RJbmZvICYmIHJlcXVlc3RJbmZvWzFdID09PSBzdGFydEF0KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIEZFVENIW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFN0YXJ0IGZldGNoaW5nLiBDaGFuZ2UgdGhlIGBpc1ZhbGlkYXRpbmdgIHN0YXRlLCB1cGRhdGUgdGhlIGNhY2hlLlxuICAgICAgICBjb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSXQgaXMgaW4gdGhlIGBpc0xvYWRpbmdgIHN0YXRlLCBpZiBhbmQgb25seSBpZiB0aGVyZSBpcyBubyBjYWNoZWQgZGF0YS5cbiAgICAgICAgLy8gVGhpcyBieXBhc3NlcyBmYWxsYmFjayBkYXRhIGFuZCBsYWdneSBkYXRhLlxuICAgICAgICBpZiAoaXNVbmRlZmluZWQoZ2V0Q2FjaGUoKS5kYXRhKSkge1xuICAgICAgICAgICAgaW5pdGlhbFN0YXRlLmlzTG9hZGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBzZXRDYWNoZShpbml0aWFsU3RhdGUpO1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIGNhY2hlIGlzIGJlaW5nIHJlbmRlcmVkIGN1cnJlbnRseSAoaXQgc2hvd3MgYSBibGFuayBwYWdlKSxcbiAgICAgICAgICAgICAgICAvLyB3ZSB0cmlnZ2VyIHRoZSBsb2FkaW5nIHNsb3cgZXZlbnQuXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2FkaW5nVGltZW91dCAmJiBpc1VuZGVmaW5lZChnZXRDYWNoZSgpLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2FkaW5nICYmIGNhbGxiYWNrU2FmZWd1YXJkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vbkxvYWRpbmdTbG93KGtleSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgY29uZmlnLmxvYWRpbmdUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHJlcXVlc3QgYW5kIHNhdmUgdGhlIHRpbWVzdGFtcC5cbiAgICAgICAgICAgICAgICAvLyBLZXkgbXVzdCBiZSB0cnV0aHkgaWYgZW50ZXJpbmcgaGVyZS5cbiAgICAgICAgICAgICAgICBGRVRDSFtrZXldID0gW1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RmV0Y2hlcihmbkFyZyksXG4gICAgICAgICAgICAgICAgICAgIGdldFRpbWVzdGFtcCgpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFtuZXdEYXRhLCBzdGFydEF0XSA9IEZFVENIW2tleV07XG4gICAgICAgICAgICBuZXdEYXRhID0gYXdhaXQgbmV3RGF0YTtcbiAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdCBpc24ndCBpbnRlcnJ1cHRlZCwgY2xlYW4gaXQgdXAgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAgICAgLy8gZGVkdXBsaWNhdGlvbiBpbnRlcnZhbC5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNsZWFudXBTdGF0ZSwgY29uZmlnLmRlZHVwaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncmUgb3RoZXIgb25nb2luZyByZXF1ZXN0KHMpLCBzdGFydGVkIGFmdGVyIHRoZSBjdXJyZW50IG9uZSxcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gaWdub3JlIHRoZSBjdXJyZW50IG9uZSB0byBhdm9pZCBwb3NzaWJsZSByYWNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgICAvLyAgIHJlcTEtLS0tLS0tLS0tLS0tLS0tLS0+cmVzMSAgICAgICAgKGN1cnJlbnQgb25lKVxuICAgICAgICAgICAgLy8gICAgICAgIHJlcTItLS0tLS0tLS0tLS0tLS0tPnJlczJcbiAgICAgICAgICAgIC8vIHRoZSByZXF1ZXN0IHRoYXQgZmlyZWQgbGF0ZXIgd2lsbCBhbHdheXMgYmUga2VwdC5cbiAgICAgICAgICAgIC8vIFRoZSB0aW1lc3RhbXAgbWF5YmUgYmUgYHVuZGVmaW5lZGAgb3IgYSBudW1iZXJcbiAgICAgICAgICAgIGlmICghRkVUQ0hba2V5XSB8fCBGRVRDSFtrZXldWzFdICE9PSBzdGFydEF0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tTYWZlZ3VhcmQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25EaXNjYXJkZWQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDbGVhciBlcnJvci5cbiAgICAgICAgICAgIGZpbmFsU3RhdGUuZXJyb3IgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdyZSBvdGhlciBtdXRhdGlvbnMocyksIHRoYXQgb3ZlcmxhcHBlZCB3aXRoIHRoZSBjdXJyZW50IHJldmFsaWRhdGlvbjpcbiAgICAgICAgICAgIC8vIGNhc2UgMTpcbiAgICAgICAgICAgIC8vICAgcmVxLS0tLS0tLS0tLS0tLS0tLS0tPnJlc1xuICAgICAgICAgICAgLy8gICAgICAgbXV0YXRlLS0tLS0tPmVuZFxuICAgICAgICAgICAgLy8gY2FzZSAyOlxuICAgICAgICAgICAgLy8gICAgICAgICByZXEtLS0tLS0tLS0tLS0+cmVzXG4gICAgICAgICAgICAvLyAgIG11dGF0ZS0tLS0tLT5lbmRcbiAgICAgICAgICAgIC8vIGNhc2UgMzpcbiAgICAgICAgICAgIC8vICAgcmVxLS0tLS0tLS0tLS0tLS0tLS0tPnJlc1xuICAgICAgICAgICAgLy8gICAgICAgbXV0YXRlLS0tLS0tLS4uLi0tLS0tLS0tLS0+XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIGlnbm9yZSB0aGUgcmV2YWxpZGF0aW9uIHJlc3VsdCAocmVzKSBiZWNhdXNlIGl0J3Mgbm8gbG9uZ2VyIGZyZXNoLlxuICAgICAgICAgICAgLy8gbWVhbndoaWxlLCBhIG5ldyByZXZhbGlkYXRpb24gc2hvdWxkIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBtdXRhdGlvbiBlbmRzLlxuICAgICAgICAgICAgY29uc3QgbXV0YXRpb25JbmZvID0gTVVUQVRJT05ba2V5XTtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQobXV0YXRpb25JbmZvKSAmJiAvLyBjYXNlIDFcbiAgICAgICAgICAgIChzdGFydEF0IDw9IG11dGF0aW9uSW5mb1swXSB8fCAvLyBjYXNlIDJcbiAgICAgICAgICAgIHN0YXJ0QXQgPD0gbXV0YXRpb25JbmZvWzFdIHx8IC8vIGNhc2UgM1xuICAgICAgICAgICAgbXV0YXRpb25JbmZvWzFdID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGZpbmlzaFJlcXVlc3RBbmRVcGRhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrU2FmZWd1YXJkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRGlzY2FyZGVkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVlcCBjb21wYXJlIHdpdGggdGhlIGxhdGVzdCBzdGF0ZSB0byBhdm9pZCBleHRyYSByZS1yZW5kZXJzLlxuICAgICAgICAgICAgLy8gRm9yIGxvY2FsIHN0YXRlLCBjb21wYXJlIGFuZCBhc3NpZ24uXG4gICAgICAgICAgICBjb25zdCBjYWNoZURhdGEgPSBnZXRDYWNoZSgpLmRhdGE7XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgY29tcGFyZSBmbiBjb3VsZCBiZSBjdXN0b20gZm5cbiAgICAgICAgICAgIC8vIGNhY2hlRGF0YSBtaWdodCBiZSBkaWZmZXJlbnQgZnJvbSBuZXdEYXRhIGV2ZW4gd2hlbiBjb21wYXJlIGZuIHJldHVybnMgVHJ1ZVxuICAgICAgICAgICAgZmluYWxTdGF0ZS5kYXRhID0gY29tcGFyZShjYWNoZURhdGEsIG5ld0RhdGEpID8gY2FjaGVEYXRhIDogbmV3RGF0YTtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIHN1Y2Nlc3NmdWwgY2FsbGJhY2sgaWYgaXQncyB0aGUgb3JpZ2luYWwgcmVxdWVzdC5cbiAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tTYWZlZ3VhcmQoKSkge1xuICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vblN1Y2Nlc3MobmV3RGF0YSwga2V5LCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjbGVhbnVwU3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb25maWcgPSBnZXRDb25maWcoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2hvdWxkUmV0cnlPbkVycm9yIH0gPSBjdXJyZW50Q29uZmlnO1xuICAgICAgICAgICAgLy8gTm90IHBhdXNlZCwgd2UgY29udGludWUgaGFuZGxpbmcgdGhlIGVycm9yLiBPdGhlcndpc2UsIGRpc2NhcmQgaXQuXG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRDb25maWcuaXNQYXVzZWQoKSkge1xuICAgICAgICAgICAgICAgIC8vIEdldCBhIG5ldyBlcnJvciwgZG9uJ3QgdXNlIGRlZXAgY29tcGFyaXNvbiBmb3IgZXJyb3JzLlxuICAgICAgICAgICAgICAgIGZpbmFsU3RhdGUuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgLy8gRXJyb3IgZXZlbnQgYW5kIHJldHJ5IGxvZ2ljLiBPbmx5IGZvciB0aGUgYWN0dWFsIHJlcXVlc3QsIG5vdFxuICAgICAgICAgICAgICAgIC8vIGRlZHVwZWQgb25lcy5cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0ICYmIGNhbGxiYWNrU2FmZWd1YXJkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbmZpZy5vbkVycm9yKGVyciwga2V5LCBjdXJyZW50Q29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFJldHJ5T25FcnJvciA9PT0gdHJ1ZSB8fCBpc0Z1bmN0aW9uKHNob3VsZFJldHJ5T25FcnJvcikgJiYgc2hvdWxkUmV0cnlPbkVycm9yKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZ2V0Q29uZmlnKCkucmV2YWxpZGF0ZU9uRm9jdXMgfHwgIWdldENvbmZpZygpLnJldmFsaWRhdGVPblJlY29ubmVjdCB8fCBpc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyBpbmFjdGl2ZSwgc3RvcC4gSXQgd2lsbCBhdXRvLXJldmFsaWRhdGUgd2hlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZm9jdXNpbmcgb3IgcmVjb25uZWN0aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gcmV0cnlpbmcsIGRlZHVwbGljYXRpb24gaXMgYWx3YXlzIGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbmZpZy5vbkVycm9yUmV0cnkoZXJyLCBrZXksIGN1cnJlbnRDb25maWcsIChfb3B0cyk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV2YWxpZGF0b3JzID0gRVZFTlRfUkVWQUxJREFUT1JTW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXZhbGlkYXRvcnMgJiYgcmV2YWxpZGF0b3JzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZhbGlkYXRvcnNbMF0ocmV2YWxpZGF0ZUV2ZW50cy5FUlJPUl9SRVZBTElEQVRFX0VWRU5ULCBfb3B0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5Q291bnQ6IChvcHRzLnJldHJ5Q291bnQgfHwgMCkgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWR1cGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYXJrIGxvYWRpbmcgYXMgc3RvcHBlZC5cbiAgICAgICAgbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgaG9vaydzIHN0YXRlLlxuICAgICAgICBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgLy8gYHNldFN0YXRlYCBpcyBpbW11dGFibGUsIGFuZCBgZXZlbnRzQ2FsbGJhY2tgLCBgZm5BcmdgLCBhbmRcbiAgICAvLyBga2V5VmFsaWRhdGluZ2AgYXJlIGRlcGVuZGluZyBvbiBga2V5YCwgc28gd2UgY2FuIGV4Y2x1ZGUgdGhlbSBmcm9tXG4gICAgLy8gdGhlIGRlcHMgYXJyYXkuXG4gICAgLy9cbiAgICAvLyBGSVhNRTpcbiAgICAvLyBgZm5gIGFuZCBgY29uZmlnYCBtaWdodCBiZSBjaGFuZ2VkIGR1cmluZyB0aGUgbGlmZWN5Y2xlLFxuICAgIC8vIGJ1dCB0aGV5IG1pZ2h0IGJlIGNoYW5nZWQgZXZlcnkgcmVuZGVyIGxpa2UgdGhpcy5cbiAgICAvLyBgdXNlU1dSKCdrZXknLCAoKSA9PiBmZXRjaCgnL2FwaS8nKSwgeyBzdXNwZW5zZTogdHJ1ZSB9KWBcbiAgICAvLyBTbyB3ZSBvbWl0IHRoZSB2YWx1ZXMgZnJvbSB0aGUgZGVwcyBhcnJheVxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0IG1pZ2h0IGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3JzLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXG4gICAgICAgIGtleSxcbiAgICAgICAgY2FjaGVcbiAgICBdKTtcbiAgICAvLyBTaW1pbGFyIHRvIHRoZSBnbG9iYWwgbXV0YXRlIGJ1dCBib3VuZCB0byB0aGUgY3VycmVudCBjYWNoZSBhbmQga2V5LlxuICAgIC8vIGBjYWNoZWAgaXNuJ3QgYWxsb3dlZCB0byBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZlY3ljbGUuXG4gICAgY29uc3QgYm91bmRNdXRhdGUgPSB1c2VDYWxsYmFjaygvLyBVc2UgY2FsbGJhY2sgdG8gbWFrZSBzdXJlIGBrZXlSZWYuY3VycmVudGAgcmV0dXJucyBsYXRlc3QgcmVzdWx0IGV2ZXJ5IHRpbWVcbiAgICAoLi4uYXJncyk9PntcbiAgICAgICAgcmV0dXJuIGludGVybmFsTXV0YXRlKGNhY2hlLCBrZXlSZWYuY3VycmVudCwgLi4uYXJncyk7XG4gICAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtdKTtcbiAgICAvLyBUaGUgbG9naWMgZm9yIHVwZGF0aW5nIHJlZnMuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICBmZXRjaGVyUmVmLmN1cnJlbnQgPSBmZXRjaGVyO1xuICAgICAgICBjb25maWdSZWYuY3VycmVudCA9IGNvbmZpZztcbiAgICAgICAgLy8gSGFuZGxlIGxhZ2d5IGRhdGEgdXBkYXRlcy4gSWYgdGhlcmUncyBjYWNoZWQgZGF0YSBvZiB0aGUgY3VycmVudCBrZXksXG4gICAgICAgIC8vIGl0J2xsIGJlIHRoZSBjb3JyZWN0IHJlZmVyZW5jZS5cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChjYWNoZWREYXRhKSkge1xuICAgICAgICAgICAgbGFnZ3lEYXRhUmVmLmN1cnJlbnQgPSBjYWNoZWREYXRhO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQWZ0ZXIgbW91bnRlZCBvciBrZXkgY2hhbmdlZC5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGlmICgha2V5KSByZXR1cm47XG4gICAgICAgIGNvbnN0IHNvZnRSZXZhbGlkYXRlID0gcmV2YWxpZGF0ZS5iaW5kKFVOREVGSU5FRCwgV0lUSF9ERURVUEUpO1xuICAgICAgICAvLyBFeHBvc2UgcmV2YWxpZGF0b3JzIHRvIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMuIFNvIHdlIGNhbiB0cmlnZ2VyXG4gICAgICAgIC8vIHJldmFsaWRhdGlvbiBmcm9tIHRoZSBvdXRzaWRlLlxuICAgICAgICBsZXQgbmV4dEZvY3VzUmV2YWxpZGF0ZWRBdCA9IDA7XG4gICAgICAgIGNvbnN0IG9uUmV2YWxpZGF0ZSA9ICh0eXBlLCBvcHRzID0ge30pPT57XG4gICAgICAgICAgICBpZiAodHlwZSA9PSByZXZhbGlkYXRlRXZlbnRzLkZPQ1VTX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0Q29uZmlnKCkucmV2YWxpZGF0ZU9uRm9jdXMgJiYgbm93ID4gbmV4dEZvY3VzUmV2YWxpZGF0ZWRBdCAmJiBpc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGb2N1c1JldmFsaWRhdGVkQXQgPSBub3cgKyBnZXRDb25maWcoKS5mb2N1c1Rocm90dGxlSW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgIHNvZnRSZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IHJldmFsaWRhdGVFdmVudHMuUkVDT05ORUNUX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdldENvbmZpZygpLnJldmFsaWRhdGVPblJlY29ubmVjdCAmJiBpc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvZnRSZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IHJldmFsaWRhdGVFdmVudHMuTVVUQVRFX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSByZXZhbGlkYXRlRXZlbnRzLkVSUk9SX1JFVkFMSURBVEVfRVZFTlQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV2YWxpZGF0ZShvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdW5zdWJFdmVudHMgPSBzdWJzY3JpYmVDYWxsYmFjayhrZXksIEVWRU5UX1JFVkFMSURBVE9SUywgb25SZXZhbGlkYXRlKTtcbiAgICAgICAgLy8gTWFyayB0aGUgY29tcG9uZW50IGFzIG1vdW50ZWQgYW5kIHVwZGF0ZSBjb3JyZXNwb25kaW5nIHJlZnMuXG4gICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGtleVJlZi5jdXJyZW50ID0ga2V5O1xuICAgICAgICBpbml0aWFsTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgLy8gS2VlcCB0aGUgb3JpZ2luYWwga2V5IGluIHRoZSBjYWNoZS5cbiAgICAgICAgc2V0Q2FjaGUoe1xuICAgICAgICAgICAgX2s6IGZuQXJnXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmlnZ2VyIGEgcmV2YWxpZGF0aW9uXG4gICAgICAgIGlmIChzaG91bGREb0luaXRpYWxSZXZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChkYXRhKSB8fCBJU19TRVJWRVIpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXZhbGlkYXRlIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAgIHNvZnRSZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERlbGF5IHRoZSByZXZhbGlkYXRlIGlmIHdlIGhhdmUgZGF0YSB0byByZXR1cm4gc28gd2Ugd29uJ3QgYmxvY2tcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJpbmcuXG4gICAgICAgICAgICAgICAgckFGKHNvZnRSZXZhbGlkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIC8vIE1hcmsgaXQgYXMgdW5tb3VudGVkLlxuICAgICAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdW5zdWJFdmVudHMoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGtleVxuICAgIF0pO1xuICAgIC8vIFBvbGxpbmdcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGxldCB0aW1lcjtcbiAgICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgcGFzc2VkIGludGVydmFsXG4gICAgICAgICAgICAvLyAuLi5vciBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHVwZGF0ZWQgZGF0YSB0byBnZXQgdGhlIGludGVydmFsXG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbCA9IGlzRnVuY3Rpb24ocmVmcmVzaEludGVydmFsKSA/IHJlZnJlc2hJbnRlcnZhbChnZXRDYWNoZSgpLmRhdGEpIDogcmVmcmVzaEludGVydmFsO1xuICAgICAgICAgICAgLy8gV2Ugb25seSBzdGFydCB0aGUgbmV4dCBpbnRlcnZhbCBpZiBgcmVmcmVzaEludGVydmFsYCBpcyBub3QgMCwgYW5kOlxuICAgICAgICAgICAgLy8gLSBgZm9yY2VgIGlzIHRydWUsIHdoaWNoIGlzIHRoZSBzdGFydCBvZiBwb2xsaW5nXG4gICAgICAgICAgICAvLyAtIG9yIGB0aW1lcmAgaXMgbm90IDAsIHdoaWNoIG1lYW5zIHRoZSBlZmZlY3Qgd2Fzbid0IGNhbmNlbGVkXG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgJiYgdGltZXIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWN1dGUsIGludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleGVjdXRlKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBPSyB0byBleGVjdXRlOlxuICAgICAgICAgICAgLy8gT25seSByZXZhbGlkYXRlIHdoZW4gdGhlIHBhZ2UgaXMgdmlzaWJsZSwgb25saW5lLCBhbmQgbm90IGVycm9yZWQuXG4gICAgICAgICAgICBpZiAoIWdldENhY2hlKCkuZXJyb3IgJiYgKHJlZnJlc2hXaGVuSGlkZGVuIHx8IGdldENvbmZpZygpLmlzVmlzaWJsZSgpKSAmJiAocmVmcmVzaFdoZW5PZmZsaW5lIHx8IGdldENvbmZpZygpLmlzT25saW5lKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZShXSVRIX0RFRFVQRSkudGhlbihuZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgdGhlIG5leHQgaW50ZXJ2YWwgdG8gY2hlY2sgYWdhaW4uXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIHRpbWVyID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICByZWZyZXNoSW50ZXJ2YWwsXG4gICAgICAgIHJlZnJlc2hXaGVuSGlkZGVuLFxuICAgICAgICByZWZyZXNoV2hlbk9mZmxpbmUsXG4gICAgICAgIGtleVxuICAgIF0pO1xuICAgIC8vIERpc3BsYXkgZGVidWcgaW5mbyBpbiBSZWFjdCBEZXZUb29scy5cbiAgICB1c2VEZWJ1Z1ZhbHVlKHJldHVybmVkRGF0YSk7XG4gICAgLy8gSW4gU3VzcGVuc2UgbW9kZSwgd2UgY2FuJ3QgcmV0dXJuIHRoZSBlbXB0eSBgZGF0YWAgc3RhdGUuXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gYGVycm9yYCwgdGhlIGBlcnJvcmAgbmVlZHMgdG8gYmUgdGhyb3duIHRvIHRoZSBlcnJvciBib3VuZGFyeS5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBgZXJyb3JgLCB0aGUgYHJldmFsaWRhdGlvbmAgcHJvbWlzZSBuZWVkcyB0byBiZSB0aHJvd24gdG9cbiAgICAvLyB0aGUgc3VzcGVuc2UgYm91bmRhcnkuXG4gICAgaWYgKHN1c3BlbnNlICYmIGlzVW5kZWZpbmVkKGRhdGEpICYmIGtleSkge1xuICAgICAgICAvLyBTV1Igc2hvdWxkIHRocm93IHdoZW4gdHJ5aW5nIHRvIHVzZSBTdXNwZW5zZSBvbiB0aGUgc2VydmVyIHdpdGggUmVhY3QgMTgsXG4gICAgICAgIC8vIHdpdGhvdXQgcHJvdmlkaW5nIGFueSBpbml0aWFsIGRhdGEuIFNlZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9zd3IvaXNzdWVzLzE4MzJcbiAgICAgICAgaWYgKCFJU19SRUFDVF9MRUdBQ1kgJiYgSVNfU0VSVkVSKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhbGxiYWNrIGRhdGEgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBzdXNwZW5zZSBpbiBTU1IuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWx3YXlzIHVwZGF0ZSBmZXRjaGVyIGFuZCBjb25maWcgcmVmcyBldmVuIHdpdGggdGhlIFN1c3BlbnNlIG1vZGUuXG4gICAgICAgIGZldGNoZXJSZWYuY3VycmVudCA9IGZldGNoZXI7XG4gICAgICAgIGNvbmZpZ1JlZi5jdXJyZW50ID0gY29uZmlnO1xuICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBjb25zdCByZXEgPSBQUkVMT0FEW2tleV07XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQocmVxKSkge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGJvdW5kTXV0YXRlKHJlcSk7XG4gICAgICAgICAgICB1c2UocHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGVycm9yKSkge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHJldmFsaWRhdGUoV0lUSF9ERURVUEUpO1xuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChyZXR1cm5lZERhdGEpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgICAgICAgICAgICAgICBwcm9taXNlLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVzZShwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG11dGF0ZTogYm91bmRNdXRhdGUsXG4gICAgICAgIGdldCBkYXRhICgpIHtcbiAgICAgICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzLmRhdGEgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybmVkRGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGVycm9yICgpIHtcbiAgICAgICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzLmVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGlzVmFsaWRhdGluZyAoKSB7XG4gICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5pc1ZhbGlkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRhdGluZztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGlzTG9hZGluZyAoKSB7XG4gICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5pc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGlzTG9hZGluZztcbiAgICAgICAgfVxuICAgIH07XG59O1xuY29uc3QgU1dSQ29uZmlnID0gT0JKRUNULmRlZmluZVByb3BlcnR5KFNXUkNvbmZpZyQxLCAnZGVmYXVsdFZhbHVlJywge1xuICAgIHZhbHVlOiBkZWZhdWx0Q29uZmlnXG59KTtcbi8qKlxuICogQSBob29rIHRvIGZldGNoIGRhdGEuXG4gKlxuICogQGxpbmsgaHR0cHM6Ly9zd3IudmVyY2VsLmFwcFxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IHVzZVNXUiBmcm9tICdzd3InXG4gKiBmdW5jdGlvbiBQcm9maWxlKCkge1xuICogICBjb25zdCB7IGRhdGEsIGVycm9yLCBpc0xvYWRpbmcgfSA9IHVzZVNXUignL2FwaS91c2VyJywgZmV0Y2hlcilcbiAqICAgaWYgKGVycm9yKSByZXR1cm4gPGRpdj5mYWlsZWQgdG8gbG9hZDwvZGl2PlxuICogICBpZiAoaXNMb2FkaW5nKSByZXR1cm4gPGRpdj5sb2FkaW5nLi4uPC9kaXY+XG4gKiAgIHJldHVybiA8ZGl2PmhlbGxvIHtkYXRhLm5hbWV9ITwvZGl2PlxuICogfVxuICogYGBgXG4gKi8gY29uc3QgdXNlU1dSID0gd2l0aEFyZ3ModXNlU1dSSGFuZGxlcik7XG5cbmV4cG9ydCB7IFNXUkNvbmZpZywgdXNlU1dSIGFzIGRlZmF1bHQsIHVuc3RhYmxlX3NlcmlhbGl6ZSB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0RXhwb3J0cyIsInVzZVJlZiIsInVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsInVzZURlYnVnVmFsdWUiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInNlcmlhbGl6ZSIsIk9CSkVDVCIsIlNXUkNvbmZpZyIsIlNXUkNvbmZpZyQxIiwiZGVmYXVsdENvbmZpZyIsIndpdGhBcmdzIiwiU1dSR2xvYmFsU3RhdGUiLCJjcmVhdGVDYWNoZUhlbHBlciIsImlzVW5kZWZpbmVkIiwiZ2V0VGltZXN0YW1wIiwiVU5ERUZJTkVEIiwiaXNGdW5jdGlvbiIsInJldmFsaWRhdGVFdmVudHMiLCJpbnRlcm5hbE11dGF0ZSIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJzdWJzY3JpYmVDYWxsYmFjayIsIklTX1NFUlZFUiIsInJBRiIsIklTX1JFQUNUX0xFR0FDWSIsIm1lcmdlT2JqZWN0cyIsIm11dGF0ZSIsInByZWxvYWQiLCJ1c2VTV1JDb25maWciLCJ1bnN0YWJsZV9zZXJpYWxpemUiLCJrZXkiLCJ1c2UiLCJwcm9taXNlIiwic3RhdHVzIiwidmFsdWUiLCJyZWFzb24iLCJ0aGVuIiwidiIsImUiLCJXSVRIX0RFRFVQRSIsImRlZHVwZSIsInVzZVNXUkhhbmRsZXIiLCJfa2V5IiwiZmV0Y2hlciIsImNvbmZpZyIsImNhY2hlIiwiY29tcGFyZSIsInN1c3BlbnNlIiwiZmFsbGJhY2tEYXRhIiwicmV2YWxpZGF0ZU9uTW91bnQiLCJyZXZhbGlkYXRlSWZTdGFsZSIsInJlZnJlc2hJbnRlcnZhbCIsInJlZnJlc2hXaGVuSGlkZGVuIiwicmVmcmVzaFdoZW5PZmZsaW5lIiwia2VlcFByZXZpb3VzRGF0YSIsIkVWRU5UX1JFVkFMSURBVE9SUyIsIk1VVEFUSU9OIiwiRkVUQ0giLCJQUkVMT0FEIiwiZ2V0IiwiZm5BcmciLCJpbml0aWFsTW91bnRlZFJlZiIsInVubW91bnRlZFJlZiIsImtleVJlZiIsImZldGNoZXJSZWYiLCJjb25maWdSZWYiLCJnZXRDb25maWciLCJjdXJyZW50IiwiaXNBY3RpdmUiLCJpc1Zpc2libGUiLCJpc09ubGluZSIsImdldENhY2hlIiwic2V0Q2FjaGUiLCJzdWJzY3JpYmVDYWNoZSIsImdldEluaXRpYWxDYWNoZSIsInN0YXRlRGVwZW5kZW5jaWVzIiwiZmFsbGJhY2siLCJpc0VxdWFsIiwicHJldiIsIl8iLCJ0IiwicmV0dXJuZWREYXRhIiwiZ2V0U25hcHNob3QiLCJzaG91bGRTdGFydFJlcXVlc3QiLCJpc1BhdXNlZCIsImdldFNlbGVjdGVkQ2FjaGUiLCJzdGF0ZSIsInNuYXBzaG90IiwiX2siLCJpc1ZhbGlkYXRpbmciLCJpc0xvYWRpbmciLCJjYWNoZWREYXRhIiwiaW5pdGlhbERhdGEiLCJjbGllbnRTbmFwc2hvdCIsInNlcnZlclNuYXBzaG90IiwibWVtb3JpemVkU25hcHNob3QiLCJuZXdTbmFwc2hvdCIsImNvbXBhcmVSZXN1bHQiLCJkYXRhIiwiZXJyb3IiLCJjYWNoZWQiLCJjYWxsYmFjayIsImlzSW5pdGlhbE1vdW50IiwiaGFzUmV2YWxpZGF0b3IiLCJsZW5ndGgiLCJsYWdneURhdGFSZWYiLCJzaG91bGREb0luaXRpYWxSZXZhbGlkYXRpb24iLCJkZWZhdWx0VmFsaWRhdGluZ1N0YXRlIiwicmV2YWxpZGF0ZSIsInJldmFsaWRhdGVPcHRzIiwiY3VycmVudEZldGNoZXIiLCJuZXdEYXRhIiwic3RhcnRBdCIsImxvYWRpbmciLCJvcHRzIiwic2hvdWxkU3RhcnROZXdSZXF1ZXN0IiwiY2FsbGJhY2tTYWZlZ3VhcmQiLCJmaW5hbFN0YXRlIiwiZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlIiwiY2xlYW51cFN0YXRlIiwicmVxdWVzdEluZm8iLCJpbml0aWFsU3RhdGUiLCJsb2FkaW5nVGltZW91dCIsInNldFRpbWVvdXQiLCJvbkxvYWRpbmdTbG93IiwiZGVkdXBpbmdJbnRlcnZhbCIsIm9uRGlzY2FyZGVkIiwibXV0YXRpb25JbmZvIiwiY2FjaGVEYXRhIiwib25TdWNjZXNzIiwiZXJyIiwiY3VycmVudENvbmZpZyIsInNob3VsZFJldHJ5T25FcnJvciIsIm9uRXJyb3IiLCJyZXZhbGlkYXRlT25Gb2N1cyIsInJldmFsaWRhdGVPblJlY29ubmVjdCIsIm9uRXJyb3JSZXRyeSIsIl9vcHRzIiwicmV2YWxpZGF0b3JzIiwiRVJST1JfUkVWQUxJREFURV9FVkVOVCIsInJldHJ5Q291bnQiLCJib3VuZE11dGF0ZSIsImFyZ3MiLCJzb2Z0UmV2YWxpZGF0ZSIsImJpbmQiLCJuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0Iiwib25SZXZhbGlkYXRlIiwidHlwZSIsIkZPQ1VTX0VWRU5UIiwibm93IiwiRGF0ZSIsImZvY3VzVGhyb3R0bGVJbnRlcnZhbCIsIlJFQ09OTkVDVF9FVkVOVCIsIk1VVEFURV9FVkVOVCIsInVuc3ViRXZlbnRzIiwidGltZXIiLCJuZXh0IiwiaW50ZXJ2YWwiLCJleGVjdXRlIiwiY2xlYXJUaW1lb3V0IiwiRXJyb3IiLCJyZXEiLCJkZWZpbmVQcm9wZXJ0eSIsInVzZVNXUiIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swr/dist/core/index.mjs\n");

/***/ })

};
;